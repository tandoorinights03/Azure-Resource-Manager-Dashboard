'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link Origin} that the service accepts. */
exports.KnownOrigin = void 0;
(function (KnownOrigin) {
    /** User */
    KnownOrigin["User"] = "user";
    /** System */
    KnownOrigin["System"] = "system";
    /** UserSystem */
    KnownOrigin["UserSystem"] = "user,system";
})(exports.KnownOrigin || (exports.KnownOrigin = {}));
/** Known values of {@link ActionType} that the service accepts. */
exports.KnownActionType = void 0;
(function (KnownActionType) {
    /** Internal */
    KnownActionType["Internal"] = "Internal";
})(exports.KnownActionType || (exports.KnownActionType = {}));
/** Known values of {@link ReportType} that the service accepts. */
exports.KnownReportType = void 0;
(function (KnownReportType) {
    /** Usage */
    KnownReportType["Usage"] = "Usage";
})(exports.KnownReportType || (exports.KnownReportType = {}));
/** Known values of {@link ReportTimeframeType} that the service accepts. */
exports.KnownReportTimeframeType = void 0;
(function (KnownReportTimeframeType) {
    /** WeekToDate */
    KnownReportTimeframeType["WeekToDate"] = "WeekToDate";
    /** MonthToDate */
    KnownReportTimeframeType["MonthToDate"] = "MonthToDate";
    /** YearToDate */
    KnownReportTimeframeType["YearToDate"] = "YearToDate";
    /** Custom */
    KnownReportTimeframeType["Custom"] = "Custom";
})(exports.KnownReportTimeframeType || (exports.KnownReportTimeframeType = {}));
/** Known values of {@link ReportGranularityType} that the service accepts. */
exports.KnownReportGranularityType = void 0;
(function (KnownReportGranularityType) {
    /** Daily */
    KnownReportGranularityType["Daily"] = "Daily";
    /** Monthly */
    KnownReportGranularityType["Monthly"] = "Monthly";
})(exports.KnownReportGranularityType || (exports.KnownReportGranularityType = {}));
/** Known values of {@link FunctionType} that the service accepts. */
exports.KnownFunctionType = void 0;
(function (KnownFunctionType) {
    /** Sum */
    KnownFunctionType["Sum"] = "Sum";
})(exports.KnownFunctionType || (exports.KnownFunctionType = {}));
/** Known values of {@link QueryColumnType} that the service accepts. */
exports.KnownQueryColumnType = void 0;
(function (KnownQueryColumnType) {
    /** The tag associated with the cost data. */
    KnownQueryColumnType["TagKey"] = "TagKey";
    /** The dimension of cost data. */
    KnownQueryColumnType["Dimension"] = "Dimension";
})(exports.KnownQueryColumnType || (exports.KnownQueryColumnType = {}));
/** Known values of {@link ReportConfigSortingType} that the service accepts. */
exports.KnownReportConfigSortingType = void 0;
(function (KnownReportConfigSortingType) {
    /** Ascending */
    KnownReportConfigSortingType["Ascending"] = "Ascending";
    /** Descending */
    KnownReportConfigSortingType["Descending"] = "Descending";
})(exports.KnownReportConfigSortingType || (exports.KnownReportConfigSortingType = {}));
/** Known values of {@link OperatorType} that the service accepts. */
exports.KnownOperatorType = void 0;
(function (KnownOperatorType) {
    /** In */
    KnownOperatorType["In"] = "In";
    /** Contains */
    KnownOperatorType["Contains"] = "Contains";
})(exports.KnownOperatorType || (exports.KnownOperatorType = {}));
/** Known values of {@link ChartType} that the service accepts. */
exports.KnownChartType = void 0;
(function (KnownChartType) {
    /** Area */
    KnownChartType["Area"] = "Area";
    /** Line */
    KnownChartType["Line"] = "Line";
    /** StackedColumn */
    KnownChartType["StackedColumn"] = "StackedColumn";
    /** GroupedColumn */
    KnownChartType["GroupedColumn"] = "GroupedColumn";
    /** Table */
    KnownChartType["Table"] = "Table";
})(exports.KnownChartType || (exports.KnownChartType = {}));
/** Known values of {@link AccumulatedType} that the service accepts. */
exports.KnownAccumulatedType = void 0;
(function (KnownAccumulatedType) {
    /** True */
    KnownAccumulatedType["True"] = "true";
    /** False */
    KnownAccumulatedType["False"] = "false";
})(exports.KnownAccumulatedType || (exports.KnownAccumulatedType = {}));
/** Known values of {@link MetricType} that the service accepts. */
exports.KnownMetricType = void 0;
(function (KnownMetricType) {
    /** ActualCost */
    KnownMetricType["ActualCost"] = "ActualCost";
    /** AmortizedCost */
    KnownMetricType["AmortizedCost"] = "AmortizedCost";
    /** Ahub */
    KnownMetricType["Ahub"] = "AHUB";
})(exports.KnownMetricType || (exports.KnownMetricType = {}));
/** Known values of {@link KpiType} that the service accepts. */
exports.KnownKpiType = void 0;
(function (KnownKpiType) {
    /** Forecast */
    KnownKpiType["Forecast"] = "Forecast";
    /** Budget */
    KnownKpiType["Budget"] = "Budget";
})(exports.KnownKpiType || (exports.KnownKpiType = {}));
/** Known values of {@link PivotType} that the service accepts. */
exports.KnownPivotType = void 0;
(function (KnownPivotType) {
    /** Dimension */
    KnownPivotType["Dimension"] = "Dimension";
    /** TagKey */
    KnownPivotType["TagKey"] = "TagKey";
})(exports.KnownPivotType || (exports.KnownPivotType = {}));
/** Known values of {@link AlertType} that the service accepts. */
exports.KnownAlertType = void 0;
(function (KnownAlertType) {
    /** Budget */
    KnownAlertType["Budget"] = "Budget";
    /** Invoice */
    KnownAlertType["Invoice"] = "Invoice";
    /** Credit */
    KnownAlertType["Credit"] = "Credit";
    /** Quota */
    KnownAlertType["Quota"] = "Quota";
    /** General */
    KnownAlertType["General"] = "General";
    /** XCloud */
    KnownAlertType["XCloud"] = "xCloud";
    /** BudgetForecast */
    KnownAlertType["BudgetForecast"] = "BudgetForecast";
})(exports.KnownAlertType || (exports.KnownAlertType = {}));
/** Known values of {@link AlertCategory} that the service accepts. */
exports.KnownAlertCategory = void 0;
(function (KnownAlertCategory) {
    /** Cost */
    KnownAlertCategory["Cost"] = "Cost";
    /** Usage */
    KnownAlertCategory["Usage"] = "Usage";
    /** Billing */
    KnownAlertCategory["Billing"] = "Billing";
    /** System */
    KnownAlertCategory["System"] = "System";
})(exports.KnownAlertCategory || (exports.KnownAlertCategory = {}));
/** Known values of {@link AlertCriteria} that the service accepts. */
exports.KnownAlertCriteria = void 0;
(function (KnownAlertCriteria) {
    /** CostThresholdExceeded */
    KnownAlertCriteria["CostThresholdExceeded"] = "CostThresholdExceeded";
    /** UsageThresholdExceeded */
    KnownAlertCriteria["UsageThresholdExceeded"] = "UsageThresholdExceeded";
    /** CreditThresholdApproaching */
    KnownAlertCriteria["CreditThresholdApproaching"] = "CreditThresholdApproaching";
    /** CreditThresholdReached */
    KnownAlertCriteria["CreditThresholdReached"] = "CreditThresholdReached";
    /** QuotaThresholdApproaching */
    KnownAlertCriteria["QuotaThresholdApproaching"] = "QuotaThresholdApproaching";
    /** QuotaThresholdReached */
    KnownAlertCriteria["QuotaThresholdReached"] = "QuotaThresholdReached";
    /** MultiCurrency */
    KnownAlertCriteria["MultiCurrency"] = "MultiCurrency";
    /** ForecastCostThresholdExceeded */
    KnownAlertCriteria["ForecastCostThresholdExceeded"] = "ForecastCostThresholdExceeded";
    /** ForecastUsageThresholdExceeded */
    KnownAlertCriteria["ForecastUsageThresholdExceeded"] = "ForecastUsageThresholdExceeded";
    /** InvoiceDueDateApproaching */
    KnownAlertCriteria["InvoiceDueDateApproaching"] = "InvoiceDueDateApproaching";
    /** InvoiceDueDateReached */
    KnownAlertCriteria["InvoiceDueDateReached"] = "InvoiceDueDateReached";
    /** CrossCloudNewDataAvailable */
    KnownAlertCriteria["CrossCloudNewDataAvailable"] = "CrossCloudNewDataAvailable";
    /** CrossCloudCollectionError */
    KnownAlertCriteria["CrossCloudCollectionError"] = "CrossCloudCollectionError";
    /** GeneralThresholdError */
    KnownAlertCriteria["GeneralThresholdError"] = "GeneralThresholdError";
})(exports.KnownAlertCriteria || (exports.KnownAlertCriteria = {}));
/** Known values of {@link AlertSource} that the service accepts. */
exports.KnownAlertSource = void 0;
(function (KnownAlertSource) {
    /** Preset */
    KnownAlertSource["Preset"] = "Preset";
    /** User */
    KnownAlertSource["User"] = "User";
})(exports.KnownAlertSource || (exports.KnownAlertSource = {}));
/** Known values of {@link AlertTimeGrainType} that the service accepts. */
exports.KnownAlertTimeGrainType = void 0;
(function (KnownAlertTimeGrainType) {
    /** None */
    KnownAlertTimeGrainType["None"] = "None";
    /** Monthly */
    KnownAlertTimeGrainType["Monthly"] = "Monthly";
    /** Quarterly */
    KnownAlertTimeGrainType["Quarterly"] = "Quarterly";
    /** Annually */
    KnownAlertTimeGrainType["Annually"] = "Annually";
    /** BillingMonth */
    KnownAlertTimeGrainType["BillingMonth"] = "BillingMonth";
    /** BillingQuarter */
    KnownAlertTimeGrainType["BillingQuarter"] = "BillingQuarter";
    /** BillingAnnual */
    KnownAlertTimeGrainType["BillingAnnual"] = "BillingAnnual";
})(exports.KnownAlertTimeGrainType || (exports.KnownAlertTimeGrainType = {}));
/** Known values of {@link AlertOperator} that the service accepts. */
exports.KnownAlertOperator = void 0;
(function (KnownAlertOperator) {
    /** None */
    KnownAlertOperator["None"] = "None";
    /** EqualTo */
    KnownAlertOperator["EqualTo"] = "EqualTo";
    /** GreaterThan */
    KnownAlertOperator["GreaterThan"] = "GreaterThan";
    /** GreaterThanOrEqualTo */
    KnownAlertOperator["GreaterThanOrEqualTo"] = "GreaterThanOrEqualTo";
    /** LessThan */
    KnownAlertOperator["LessThan"] = "LessThan";
    /** LessThanOrEqualTo */
    KnownAlertOperator["LessThanOrEqualTo"] = "LessThanOrEqualTo";
})(exports.KnownAlertOperator || (exports.KnownAlertOperator = {}));
/** Known values of {@link AlertStatus} that the service accepts. */
exports.KnownAlertStatus = void 0;
(function (KnownAlertStatus) {
    /** None */
    KnownAlertStatus["None"] = "None";
    /** Active */
    KnownAlertStatus["Active"] = "Active";
    /** Overridden */
    KnownAlertStatus["Overridden"] = "Overridden";
    /** Resolved */
    KnownAlertStatus["Resolved"] = "Resolved";
    /** Dismissed */
    KnownAlertStatus["Dismissed"] = "Dismissed";
})(exports.KnownAlertStatus || (exports.KnownAlertStatus = {}));
/** Known values of {@link ExternalCloudProviderType} that the service accepts. */
exports.KnownExternalCloudProviderType = void 0;
(function (KnownExternalCloudProviderType) {
    /** ExternalSubscriptions */
    KnownExternalCloudProviderType["ExternalSubscriptions"] = "externalSubscriptions";
    /** ExternalBillingAccounts */
    KnownExternalCloudProviderType["ExternalBillingAccounts"] = "externalBillingAccounts";
})(exports.KnownExternalCloudProviderType || (exports.KnownExternalCloudProviderType = {}));
/** Known values of {@link ForecastType} that the service accepts. */
exports.KnownForecastType = void 0;
(function (KnownForecastType) {
    /** Usage */
    KnownForecastType["Usage"] = "Usage";
    /** ActualCost */
    KnownForecastType["ActualCost"] = "ActualCost";
    /** AmortizedCost */
    KnownForecastType["AmortizedCost"] = "AmortizedCost";
})(exports.KnownForecastType || (exports.KnownForecastType = {}));
/** Known values of {@link ForecastTimeframe} that the service accepts. */
exports.KnownForecastTimeframe = void 0;
(function (KnownForecastTimeframe) {
    /** Custom */
    KnownForecastTimeframe["Custom"] = "Custom";
})(exports.KnownForecastTimeframe || (exports.KnownForecastTimeframe = {}));
/** Known values of {@link GranularityType} that the service accepts. */
exports.KnownGranularityType = void 0;
(function (KnownGranularityType) {
    /** Daily */
    KnownGranularityType["Daily"] = "Daily";
})(exports.KnownGranularityType || (exports.KnownGranularityType = {}));
/** Known values of {@link FunctionName} that the service accepts. */
exports.KnownFunctionName = void 0;
(function (KnownFunctionName) {
    /** PreTaxCostUSD */
    KnownFunctionName["PreTaxCostUSD"] = "PreTaxCostUSD";
    /** Cost */
    KnownFunctionName["Cost"] = "Cost";
    /** CostUSD */
    KnownFunctionName["CostUSD"] = "CostUSD";
    /** PreTaxCost */
    KnownFunctionName["PreTaxCost"] = "PreTaxCost";
})(exports.KnownFunctionName || (exports.KnownFunctionName = {}));
/** Known values of {@link ForecastOperatorType} that the service accepts. */
exports.KnownForecastOperatorType = void 0;
(function (KnownForecastOperatorType) {
    /** In */
    KnownForecastOperatorType["In"] = "In";
})(exports.KnownForecastOperatorType || (exports.KnownForecastOperatorType = {}));
/** Known values of {@link ExportType} that the service accepts. */
exports.KnownExportType = void 0;
(function (KnownExportType) {
    /** Usage */
    KnownExportType["Usage"] = "Usage";
    /** ActualCost */
    KnownExportType["ActualCost"] = "ActualCost";
    /** AmortizedCost */
    KnownExportType["AmortizedCost"] = "AmortizedCost";
})(exports.KnownExportType || (exports.KnownExportType = {}));
/** Known values of {@link TimeframeType} that the service accepts. */
exports.KnownTimeframeType = void 0;
(function (KnownTimeframeType) {
    /** MonthToDate */
    KnownTimeframeType["MonthToDate"] = "MonthToDate";
    /** BillingMonthToDate */
    KnownTimeframeType["BillingMonthToDate"] = "BillingMonthToDate";
    /** TheLastMonth */
    KnownTimeframeType["TheLastMonth"] = "TheLastMonth";
    /** TheLastBillingMonth */
    KnownTimeframeType["TheLastBillingMonth"] = "TheLastBillingMonth";
    /** WeekToDate */
    KnownTimeframeType["WeekToDate"] = "WeekToDate";
    /** Custom */
    KnownTimeframeType["Custom"] = "Custom";
})(exports.KnownTimeframeType || (exports.KnownTimeframeType = {}));
/** Known values of {@link QueryOperatorType} that the service accepts. */
exports.KnownQueryOperatorType = void 0;
(function (KnownQueryOperatorType) {
    /** In */
    KnownQueryOperatorType["In"] = "In";
})(exports.KnownQueryOperatorType || (exports.KnownQueryOperatorType = {}));
/** Known values of {@link OperationStatusType} that the service accepts. */
exports.KnownOperationStatusType = void 0;
(function (KnownOperationStatusType) {
    /** Running */
    KnownOperationStatusType["Running"] = "Running";
    /** Completed */
    KnownOperationStatusType["Completed"] = "Completed";
    /** Failed */
    KnownOperationStatusType["Failed"] = "Failed";
})(exports.KnownOperationStatusType || (exports.KnownOperationStatusType = {}));
/** Known values of {@link ReservationReportSchema} that the service accepts. */
exports.KnownReservationReportSchema = void 0;
(function (KnownReservationReportSchema) {
    /** InstanceFlexibilityGroup */
    KnownReservationReportSchema["InstanceFlexibilityGroup"] = "InstanceFlexibilityGroup";
    /** InstanceFlexibilityRatio */
    KnownReservationReportSchema["InstanceFlexibilityRatio"] = "InstanceFlexibilityRatio";
    /** InstanceId */
    KnownReservationReportSchema["InstanceId"] = "InstanceId";
    /** Kind */
    KnownReservationReportSchema["Kind"] = "Kind";
    /** ReservationId */
    KnownReservationReportSchema["ReservationId"] = "ReservationId";
    /** ReservationOrderId */
    KnownReservationReportSchema["ReservationOrderId"] = "ReservationOrderId";
    /** ReservedHours */
    KnownReservationReportSchema["ReservedHours"] = "ReservedHours";
    /** SkuName */
    KnownReservationReportSchema["SkuName"] = "SkuName";
    /** TotalReservedQuantity */
    KnownReservationReportSchema["TotalReservedQuantity"] = "TotalReservedQuantity";
    /** UsageDate */
    KnownReservationReportSchema["UsageDate"] = "UsageDate";
    /** UsedHours */
    KnownReservationReportSchema["UsedHours"] = "UsedHours";
})(exports.KnownReservationReportSchema || (exports.KnownReservationReportSchema = {}));
/** Known values of {@link StatusType} that the service accepts. */
exports.KnownStatusType = void 0;
(function (KnownStatusType) {
    /** Active */
    KnownStatusType["Active"] = "Active";
    /** Inactive */
    KnownStatusType["Inactive"] = "Inactive";
})(exports.KnownStatusType || (exports.KnownStatusType = {}));
/** Known values of {@link RecurrenceType} that the service accepts. */
exports.KnownRecurrenceType = void 0;
(function (KnownRecurrenceType) {
    /** Daily */
    KnownRecurrenceType["Daily"] = "Daily";
    /** Weekly */
    KnownRecurrenceType["Weekly"] = "Weekly";
    /** Monthly */
    KnownRecurrenceType["Monthly"] = "Monthly";
    /** Annually */
    KnownRecurrenceType["Annually"] = "Annually";
})(exports.KnownRecurrenceType || (exports.KnownRecurrenceType = {}));
/** Known values of {@link FormatType} that the service accepts. */
exports.KnownFormatType = void 0;
(function (KnownFormatType) {
    /** Csv */
    KnownFormatType["Csv"] = "Csv";
})(exports.KnownFormatType || (exports.KnownFormatType = {}));
/** Known values of {@link ExecutionType} that the service accepts. */
exports.KnownExecutionType = void 0;
(function (KnownExecutionType) {
    /** OnDemand */
    KnownExecutionType["OnDemand"] = "OnDemand";
    /** Scheduled */
    KnownExecutionType["Scheduled"] = "Scheduled";
})(exports.KnownExecutionType || (exports.KnownExecutionType = {}));
/** Known values of {@link ExecutionStatus} that the service accepts. */
exports.KnownExecutionStatus = void 0;
(function (KnownExecutionStatus) {
    /** Queued */
    KnownExecutionStatus["Queued"] = "Queued";
    /** InProgress */
    KnownExecutionStatus["InProgress"] = "InProgress";
    /** Completed */
    KnownExecutionStatus["Completed"] = "Completed";
    /** Failed */
    KnownExecutionStatus["Failed"] = "Failed";
    /** Timeout */
    KnownExecutionStatus["Timeout"] = "Timeout";
    /** NewDataNotAvailable */
    KnownExecutionStatus["NewDataNotAvailable"] = "NewDataNotAvailable";
    /** DataNotAvailable */
    KnownExecutionStatus["DataNotAvailable"] = "DataNotAvailable";
})(exports.KnownExecutionStatus || (exports.KnownExecutionStatus = {}));
/** Known values of {@link CostDetailsMetricType} that the service accepts. */
exports.KnownCostDetailsMetricType = void 0;
(function (KnownCostDetailsMetricType) {
    /** Actual cost data. */
    KnownCostDetailsMetricType["ActualCostCostDetailsMetricType"] = "ActualCost";
    /** Amortized cost data. */
    KnownCostDetailsMetricType["AmortizedCostCostDetailsMetricType"] = "AmortizedCost";
})(exports.KnownCostDetailsMetricType || (exports.KnownCostDetailsMetricType = {}));
/** Known values of {@link CostDetailsStatusType} that the service accepts. */
exports.KnownCostDetailsStatusType = void 0;
(function (KnownCostDetailsStatusType) {
    /** Operation is Completed. */
    KnownCostDetailsStatusType["CompletedCostDetailsStatusType"] = "Completed";
    /** Operation is Completed and no cost data found. */
    KnownCostDetailsStatusType["NoDataFoundCostDetailsStatusType"] = "NoDataFound";
    /** Operation Failed. */
    KnownCostDetailsStatusType["FailedCostDetailsStatusType"] = "Failed";
})(exports.KnownCostDetailsStatusType || (exports.KnownCostDetailsStatusType = {}));
/** Known values of {@link CostDetailsDataFormat} that the service accepts. */
exports.KnownCostDetailsDataFormat = void 0;
(function (KnownCostDetailsDataFormat) {
    /** Csv data format. */
    KnownCostDetailsDataFormat["CsvCostDetailsDataFormat"] = "Csv";
})(exports.KnownCostDetailsDataFormat || (exports.KnownCostDetailsDataFormat = {}));
/** Known values of {@link GenerateDetailedCostReportMetricType} that the service accepts. */
exports.KnownGenerateDetailedCostReportMetricType = void 0;
(function (KnownGenerateDetailedCostReportMetricType) {
    /** ActualCost */
    KnownGenerateDetailedCostReportMetricType["ActualCost"] = "ActualCost";
    /** AmortizedCost */
    KnownGenerateDetailedCostReportMetricType["AmortizedCost"] = "AmortizedCost";
})(exports.KnownGenerateDetailedCostReportMetricType || (exports.KnownGenerateDetailedCostReportMetricType = {}));
/** Known values of {@link ReportOperationStatusType} that the service accepts. */
exports.KnownReportOperationStatusType = void 0;
(function (KnownReportOperationStatusType) {
    /** InProgress */
    KnownReportOperationStatusType["InProgress"] = "InProgress";
    /** Completed */
    KnownReportOperationStatusType["Completed"] = "Completed";
    /** Failed */
    KnownReportOperationStatusType["Failed"] = "Failed";
    /** Queued */
    KnownReportOperationStatusType["Queued"] = "Queued";
    /** NoDataFound */
    KnownReportOperationStatusType["NoDataFound"] = "NoDataFound";
    /** ReadyToDownload */
    KnownReportOperationStatusType["ReadyToDownload"] = "ReadyToDownload";
    /** TimedOut */
    KnownReportOperationStatusType["TimedOut"] = "TimedOut";
})(exports.KnownReportOperationStatusType || (exports.KnownReportOperationStatusType = {}));
/** Known values of {@link FileFormat} that the service accepts. */
exports.KnownFileFormat = void 0;
(function (KnownFileFormat) {
    /** Csv */
    KnownFileFormat["Csv"] = "Csv";
})(exports.KnownFileFormat || (exports.KnownFileFormat = {}));
/** Known values of {@link ScheduleFrequency} that the service accepts. */
exports.KnownScheduleFrequency = void 0;
(function (KnownScheduleFrequency) {
    /** Cost analysis data will be emailed every day. */
    KnownScheduleFrequency["Daily"] = "Daily";
    /** Cost analysis data will be emailed every week. */
    KnownScheduleFrequency["Weekly"] = "Weekly";
    /** Cost analysis data will be emailed every month. */
    KnownScheduleFrequency["Monthly"] = "Monthly";
})(exports.KnownScheduleFrequency || (exports.KnownScheduleFrequency = {}));
/** Known values of {@link DaysOfWeek} that the service accepts. */
exports.KnownDaysOfWeek = void 0;
(function (KnownDaysOfWeek) {
    /** Monday */
    KnownDaysOfWeek["Monday"] = "Monday";
    /** Tuesday */
    KnownDaysOfWeek["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownDaysOfWeek["Wednesday"] = "Wednesday";
    /** Thursday */
    KnownDaysOfWeek["Thursday"] = "Thursday";
    /** Friday */
    KnownDaysOfWeek["Friday"] = "Friday";
    /** Saturday */
    KnownDaysOfWeek["Saturday"] = "Saturday";
    /** Sunday */
    KnownDaysOfWeek["Sunday"] = "Sunday";
})(exports.KnownDaysOfWeek || (exports.KnownDaysOfWeek = {}));
/** Known values of {@link WeeksOfMonth} that the service accepts. */
exports.KnownWeeksOfMonth = void 0;
(function (KnownWeeksOfMonth) {
    /** First */
    KnownWeeksOfMonth["First"] = "First";
    /** Second */
    KnownWeeksOfMonth["Second"] = "Second";
    /** Third */
    KnownWeeksOfMonth["Third"] = "Third";
    /** Fourth */
    KnownWeeksOfMonth["Fourth"] = "Fourth";
    /** Last */
    KnownWeeksOfMonth["Last"] = "Last";
})(exports.KnownWeeksOfMonth || (exports.KnownWeeksOfMonth = {}));
/** Known values of {@link ScheduledActionStatus} that the service accepts. */
exports.KnownScheduledActionStatus = void 0;
(function (KnownScheduledActionStatus) {
    /** Scheduled action is saved but will not be run. */
    KnownScheduledActionStatus["Disabled"] = "Disabled";
    /** Scheduled action is saved and will be run. */
    KnownScheduledActionStatus["Enabled"] = "Enabled";
    /** Scheduled action is expired. */
    KnownScheduledActionStatus["Expired"] = "Expired";
})(exports.KnownScheduledActionStatus || (exports.KnownScheduledActionStatus = {}));
/** Known values of {@link ScheduledActionKind} that the service accepts. */
exports.KnownScheduledActionKind = void 0;
(function (KnownScheduledActionKind) {
    /** Cost analysis data will be emailed. */
    KnownScheduledActionKind["Email"] = "Email";
    /** Cost anomaly information will be emailed. Available only on subscription scope at daily frequency. If no anomaly is detected on the resource, an email won't be sent. */
    KnownScheduledActionKind["InsightAlert"] = "InsightAlert";
})(exports.KnownScheduledActionKind || (exports.KnownScheduledActionKind = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link CheckNameAvailabilityReason} that the service accepts. */
exports.KnownCheckNameAvailabilityReason = void 0;
(function (KnownCheckNameAvailabilityReason) {
    /** Invalid */
    KnownCheckNameAvailabilityReason["Invalid"] = "Invalid";
    /** AlreadyExists */
    KnownCheckNameAvailabilityReason["AlreadyExists"] = "AlreadyExists";
})(exports.KnownCheckNameAvailabilityReason || (exports.KnownCheckNameAvailabilityReason = {}));
/** Known values of {@link LookBackPeriod} that the service accepts. */
exports.KnownLookBackPeriod = void 0;
(function (KnownLookBackPeriod) {
    /** 7 days used to look back. */
    KnownLookBackPeriod["Last7Days"] = "Last7Days";
    /** 30 days used to look back. */
    KnownLookBackPeriod["Last30Days"] = "Last30Days";
    /** 60 days used to look back. */
    KnownLookBackPeriod["Last60Days"] = "Last60Days";
})(exports.KnownLookBackPeriod || (exports.KnownLookBackPeriod = {}));
/** Known values of {@link Grain} that the service accepts. */
exports.KnownGrain = void 0;
(function (KnownGrain) {
    /** Hourly grain corresponds to value per hour. */
    KnownGrain["Hourly"] = "Hourly";
    /** Hourly grain corresponds to value per day. */
    KnownGrain["Daily"] = "Daily";
    /** Hourly grain corresponds to value per month. */
    KnownGrain["Monthly"] = "Monthly";
})(exports.KnownGrain || (exports.KnownGrain = {}));
/** Known values of {@link Term} that the service accepts. */
exports.KnownTerm = void 0;
(function (KnownTerm) {
    /** Benefit term is 1 year. */
    KnownTerm["P1Y"] = "P1Y";
    /** Benefit term is 3 years. */
    KnownTerm["P3Y"] = "P3Y";
})(exports.KnownTerm || (exports.KnownTerm = {}));
/** Known values of {@link Scope} that the service accepts. */
exports.KnownScope = void 0;
(function (KnownScope) {
    /** Single scope recommendation. */
    KnownScope["Single"] = "Single";
    /** Shared scope recommendation. */
    KnownScope["Shared"] = "Shared";
})(exports.KnownScope || (exports.KnownScope = {}));
/** Known values of {@link BenefitKind} that the service accepts. */
exports.KnownBenefitKind = void 0;
(function (KnownBenefitKind) {
    /** Benefit is IncludedQuantity. */
    KnownBenefitKind["IncludedQuantity"] = "IncludedQuantity";
    /** Benefit is Reservation. */
    KnownBenefitKind["Reservation"] = "Reservation";
    /** Benefit is SavingsPlan. */
    KnownBenefitKind["SavingsPlan"] = "SavingsPlan";
})(exports.KnownBenefitKind || (exports.KnownBenefitKind = {}));
/** Known values of {@link GrainParameter} that the service accepts. */
exports.KnownGrainParameter = void 0;
(function (KnownGrainParameter) {
    /** Hourly grain corresponds to value per hour. */
    KnownGrainParameter["Hourly"] = "Hourly";
    /** Hourly grain corresponds to value per day. */
    KnownGrainParameter["Daily"] = "Daily";
    /** Hourly grain corresponds to value per month. */
    KnownGrainParameter["Monthly"] = "Monthly";
})(exports.KnownGrainParameter || (exports.KnownGrainParameter = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CostManagementOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            actionType: {
                serializedName: "actionType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            }
        }
    }
};
const ErrorDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetails",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ViewListResult = {
    type: {
        name: "Composite",
        className: "ViewListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "View"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReportConfigTimePeriod = {
    type: {
        name: "Composite",
        className: "ReportConfigTimePeriod",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ReportConfigDataset = {
    type: {
        name: "Composite",
        className: "ReportConfigDataset",
        modelProperties: {
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "ReportConfigDatasetConfiguration"
                }
            },
            aggregation: {
                serializedName: "aggregation",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ReportConfigAggregation" }
                    }
                }
            },
            grouping: {
                constraints: {
                    MaxItems: 2
                },
                serializedName: "grouping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReportConfigGrouping"
                        }
                    }
                }
            },
            sorting: {
                serializedName: "sorting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReportConfigSorting"
                        }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "Composite",
                    className: "ReportConfigFilter"
                }
            }
        }
    }
};
const ReportConfigDatasetConfiguration = {
    type: {
        name: "Composite",
        className: "ReportConfigDatasetConfiguration",
        modelProperties: {
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ReportConfigAggregation = {
    type: {
        name: "Composite",
        className: "ReportConfigAggregation",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            function: {
                serializedName: "function",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReportConfigGrouping = {
    type: {
        name: "Composite",
        className: "ReportConfigGrouping",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReportConfigSorting = {
    type: {
        name: "Composite",
        className: "ReportConfigSorting",
        modelProperties: {
            direction: {
                serializedName: "direction",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReportConfigFilter = {
    type: {
        name: "Composite",
        className: "ReportConfigFilter",
        modelProperties: {
            and: {
                constraints: {
                    MinItems: 2
                },
                serializedName: "and",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReportConfigFilter"
                        }
                    }
                }
            },
            or: {
                constraints: {
                    MinItems: 2
                },
                serializedName: "or",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReportConfigFilter"
                        }
                    }
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Composite",
                    className: "ReportConfigComparisonExpression"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Composite",
                    className: "ReportConfigComparisonExpression"
                }
            }
        }
    }
};
const ReportConfigComparisonExpression = {
    type: {
        name: "Composite",
        className: "ReportConfigComparisonExpression",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            values: {
                constraints: {
                    MinItems: 1
                },
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const KpiProperties = {
    type: {
        name: "Composite",
        className: "KpiProperties",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PivotProperties = {
    type: {
        name: "Composite",
        className: "PivotProperties",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CostManagementProxyResource = {
    type: {
        name: "Composite",
        className: "CostManagementProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertsResult = {
    type: {
        name: "Composite",
        className: "AlertsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Alert"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertPropertiesDefinition = {
    type: {
        name: "Composite",
        className: "AlertPropertiesDefinition",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            criteria: {
                serializedName: "criteria",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertPropertiesDetails = {
    type: {
        name: "Composite",
        className: "AlertPropertiesDetails",
        modelProperties: {
            timeGrainType: {
                serializedName: "timeGrainType",
                type: {
                    name: "String"
                }
            },
            periodStartDate: {
                serializedName: "periodStartDate",
                type: {
                    name: "String"
                }
            },
            triggeredBy: {
                serializedName: "triggeredBy",
                type: {
                    name: "String"
                }
            },
            resourceGroupFilter: {
                serializedName: "resourceGroupFilter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "any"
                        }
                    }
                }
            },
            resourceFilter: {
                serializedName: "resourceFilter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "any"
                        }
                    }
                }
            },
            meterFilter: {
                serializedName: "meterFilter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "any"
                        }
                    }
                }
            },
            tagFilter: {
                serializedName: "tagFilter",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            threshold: {
                serializedName: "threshold",
                type: {
                    name: "Number"
                }
            },
            operator: {
                serializedName: "operator",
                type: {
                    name: "String"
                }
            },
            amount: {
                serializedName: "amount",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            currentSpend: {
                serializedName: "currentSpend",
                type: {
                    name: "Number"
                }
            },
            contactEmails: {
                serializedName: "contactEmails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contactGroups: {
                serializedName: "contactGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contactRoles: {
                serializedName: "contactRoles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            overridingAlert: {
                serializedName: "overridingAlert",
                type: {
                    name: "String"
                }
            },
            departmentName: {
                serializedName: "departmentName",
                type: {
                    name: "String"
                }
            },
            companyName: {
                serializedName: "companyName",
                type: {
                    name: "String"
                }
            },
            enrollmentNumber: {
                serializedName: "enrollmentNumber",
                type: {
                    name: "String"
                }
            },
            enrollmentStartDate: {
                serializedName: "enrollmentStartDate",
                type: {
                    name: "String"
                }
            },
            enrollmentEndDate: {
                serializedName: "enrollmentEndDate",
                type: {
                    name: "String"
                }
            },
            invoicingThreshold: {
                serializedName: "invoicingThreshold",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DismissAlertPayload = {
    type: {
        name: "Composite",
        className: "DismissAlertPayload",
        modelProperties: {
            definition: {
                serializedName: "properties.definition",
                type: {
                    name: "Composite",
                    className: "AlertPropertiesDefinition"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "properties.details",
                type: {
                    name: "Composite",
                    className: "AlertPropertiesDetails"
                }
            },
            costEntityId: {
                serializedName: "properties.costEntityId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            creationTime: {
                serializedName: "properties.creationTime",
                type: {
                    name: "String"
                }
            },
            closeTime: {
                serializedName: "properties.closeTime",
                type: {
                    name: "String"
                }
            },
            modificationTime: {
                serializedName: "properties.modificationTime",
                type: {
                    name: "String"
                }
            },
            statusModificationUserName: {
                serializedName: "properties.statusModificationUserName",
                type: {
                    name: "String"
                }
            },
            statusModificationTime: {
                serializedName: "properties.statusModificationTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ForecastDefinition = {
    type: {
        name: "Composite",
        className: "ForecastDefinition",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            timeframe: {
                serializedName: "timeframe",
                required: true,
                type: {
                    name: "String"
                }
            },
            timePeriod: {
                serializedName: "timePeriod",
                type: {
                    name: "Composite",
                    className: "ForecastTimePeriod"
                }
            },
            dataset: {
                serializedName: "dataset",
                type: {
                    name: "Composite",
                    className: "ForecastDataset"
                }
            },
            includeActualCost: {
                serializedName: "includeActualCost",
                type: {
                    name: "Boolean"
                }
            },
            includeFreshPartialCost: {
                serializedName: "includeFreshPartialCost",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ForecastTimePeriod = {
    type: {
        name: "Composite",
        className: "ForecastTimePeriod",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ForecastDataset = {
    type: {
        name: "Composite",
        className: "ForecastDataset",
        modelProperties: {
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "ForecastDatasetConfiguration"
                }
            },
            aggregation: {
                serializedName: "aggregation",
                required: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ForecastAggregation" }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "Composite",
                    className: "ForecastFilter"
                }
            }
        }
    }
};
const ForecastDatasetConfiguration = {
    type: {
        name: "Composite",
        className: "ForecastDatasetConfiguration",
        modelProperties: {
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ForecastAggregation = {
    type: {
        name: "Composite",
        className: "ForecastAggregation",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            function: {
                serializedName: "function",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ForecastFilter = {
    type: {
        name: "Composite",
        className: "ForecastFilter",
        modelProperties: {
            and: {
                constraints: {
                    MinItems: 2
                },
                serializedName: "and",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ForecastFilter"
                        }
                    }
                }
            },
            or: {
                constraints: {
                    MinItems: 2
                },
                serializedName: "or",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ForecastFilter"
                        }
                    }
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Composite",
                    className: "ForecastComparisonExpression"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Composite",
                    className: "ForecastComparisonExpression"
                }
            }
        }
    }
};
const ForecastComparisonExpression = {
    type: {
        name: "Composite",
        className: "ForecastComparisonExpression",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            values: {
                constraints: {
                    MinItems: 1
                },
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ForecastColumn = {
    type: {
        name: "Composite",
        className: "ForecastColumn",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CostManagementResource = {
    type: {
        name: "Composite",
        className: "CostManagementResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "eTag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DimensionsListResult = {
    type: {
        name: "Composite",
        className: "DimensionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            }
        }
    }
};
const QueryDefinition = {
    type: {
        name: "Composite",
        className: "QueryDefinition",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            timeframe: {
                serializedName: "timeframe",
                required: true,
                type: {
                    name: "String"
                }
            },
            timePeriod: {
                serializedName: "timePeriod",
                type: {
                    name: "Composite",
                    className: "QueryTimePeriod"
                }
            },
            dataset: {
                serializedName: "dataset",
                type: {
                    name: "Composite",
                    className: "QueryDataset"
                }
            }
        }
    }
};
const QueryTimePeriod = {
    type: {
        name: "Composite",
        className: "QueryTimePeriod",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const QueryDataset = {
    type: {
        name: "Composite",
        className: "QueryDataset",
        modelProperties: {
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "QueryDatasetConfiguration"
                }
            },
            aggregation: {
                serializedName: "aggregation",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "QueryAggregation" } }
                }
            },
            grouping: {
                constraints: {
                    MaxItems: 2
                },
                serializedName: "grouping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryGrouping"
                        }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "Composite",
                    className: "QueryFilter"
                }
            }
        }
    }
};
const QueryDatasetConfiguration = {
    type: {
        name: "Composite",
        className: "QueryDatasetConfiguration",
        modelProperties: {
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const QueryAggregation = {
    type: {
        name: "Composite",
        className: "QueryAggregation",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            function: {
                serializedName: "function",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryGrouping = {
    type: {
        name: "Composite",
        className: "QueryGrouping",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryFilter = {
    type: {
        name: "Composite",
        className: "QueryFilter",
        modelProperties: {
            and: {
                constraints: {
                    MinItems: 2
                },
                serializedName: "and",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryFilter"
                        }
                    }
                }
            },
            or: {
                constraints: {
                    MinItems: 2
                },
                serializedName: "or",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryFilter"
                        }
                    }
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Composite",
                    className: "QueryComparisonExpression"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Composite",
                    className: "QueryComparisonExpression"
                }
            }
        }
    }
};
const QueryComparisonExpression = {
    type: {
        name: "Composite",
        className: "QueryComparisonExpression",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            values: {
                constraints: {
                    MinItems: 1
                },
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const QueryColumn = {
    type: {
        name: "Composite",
        className: "QueryColumn",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationStatus = {
    type: {
        name: "Composite",
        className: "OperationStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            reportUrl: {
                serializedName: "properties.reportUrl",
                type: {
                    name: "String"
                }
            },
            validUntil: {
                serializedName: "properties.validUntil",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ExportListResult = {
    type: {
        name: "Composite",
        className: "ExportListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Export"
                        }
                    }
                }
            }
        }
    }
};
const ExportSchedule = {
    type: {
        name: "Composite",
        className: "ExportSchedule",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            recurrence: {
                serializedName: "recurrence",
                type: {
                    name: "String"
                }
            },
            recurrencePeriod: {
                serializedName: "recurrencePeriod",
                type: {
                    name: "Composite",
                    className: "ExportRecurrencePeriod"
                }
            }
        }
    }
};
const ExportRecurrencePeriod = {
    type: {
        name: "Composite",
        className: "ExportRecurrencePeriod",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            to: {
                serializedName: "to",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CommonExportProperties = {
    type: {
        name: "Composite",
        className: "CommonExportProperties",
        modelProperties: {
            format: {
                serializedName: "format",
                type: {
                    name: "String"
                }
            },
            deliveryInfo: {
                serializedName: "deliveryInfo",
                type: {
                    name: "Composite",
                    className: "ExportDeliveryInfo"
                }
            },
            definition: {
                serializedName: "definition",
                type: {
                    name: "Composite",
                    className: "ExportDefinition"
                }
            },
            runHistory: {
                serializedName: "runHistory",
                type: {
                    name: "Composite",
                    className: "ExportExecutionListResult"
                }
            },
            partitionData: {
                serializedName: "partitionData",
                type: {
                    name: "Boolean"
                }
            },
            nextRunTimeEstimate: {
                serializedName: "nextRunTimeEstimate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ExportDeliveryInfo = {
    type: {
        name: "Composite",
        className: "ExportDeliveryInfo",
        modelProperties: {
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "ExportDeliveryDestination"
                }
            }
        }
    }
};
const ExportDeliveryDestination = {
    type: {
        name: "Composite",
        className: "ExportDeliveryDestination",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            container: {
                serializedName: "container",
                required: true,
                type: {
                    name: "String"
                }
            },
            rootFolderPath: {
                serializedName: "rootFolderPath",
                type: {
                    name: "String"
                }
            },
            sasToken: {
                serializedName: "sasToken",
                type: {
                    name: "String"
                }
            },
            storageAccount: {
                serializedName: "storageAccount",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExportDefinition = {
    type: {
        name: "Composite",
        className: "ExportDefinition",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            timeframe: {
                serializedName: "timeframe",
                required: true,
                type: {
                    name: "String"
                }
            },
            timePeriod: {
                serializedName: "timePeriod",
                type: {
                    name: "Composite",
                    className: "ExportTimePeriod"
                }
            },
            dataSet: {
                serializedName: "dataSet",
                type: {
                    name: "Composite",
                    className: "ExportDataset"
                }
            }
        }
    }
};
const ExportTimePeriod = {
    type: {
        name: "Composite",
        className: "ExportTimePeriod",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ExportDataset = {
    type: {
        name: "Composite",
        className: "ExportDataset",
        modelProperties: {
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "ExportDatasetConfiguration"
                }
            }
        }
    }
};
const ExportDatasetConfiguration = {
    type: {
        name: "Composite",
        className: "ExportDatasetConfiguration",
        modelProperties: {
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ExportExecutionListResult = {
    type: {
        name: "Composite",
        className: "ExportExecutionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExportRun"
                        }
                    }
                }
            }
        }
    }
};
const GenerateCostDetailsReportRequestDefinition = {
    type: {
        name: "Composite",
        className: "GenerateCostDetailsReportRequestDefinition",
        modelProperties: {
            metric: {
                serializedName: "metric",
                type: {
                    name: "String"
                }
            },
            timePeriod: {
                serializedName: "timePeriod",
                type: {
                    name: "Composite",
                    className: "CostDetailsTimePeriod"
                }
            },
            billingPeriod: {
                serializedName: "billingPeriod",
                type: {
                    name: "String"
                }
            },
            invoiceId: {
                serializedName: "invoiceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CostDetailsTimePeriod = {
    type: {
        name: "Composite",
        className: "CostDetailsTimePeriod",
        modelProperties: {
            start: {
                serializedName: "start",
                required: true,
                type: {
                    name: "String"
                }
            },
            end: {
                serializedName: "end",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CostDetailsOperationResults = {
    type: {
        name: "Composite",
        className: "CostDetailsOperationResults",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            validTill: {
                serializedName: "validTill",
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            },
            manifestVersion: {
                serializedName: "manifest.manifestVersion",
                type: {
                    name: "String"
                }
            },
            dataFormat: {
                serializedName: "manifest.dataFormat",
                type: {
                    name: "String"
                }
            },
            byteCount: {
                serializedName: "manifest.byteCount",
                type: {
                    name: "Number"
                }
            },
            blobCount: {
                serializedName: "manifest.blobCount",
                type: {
                    name: "Number"
                }
            },
            compressData: {
                serializedName: "manifest.compressData",
                type: {
                    name: "Boolean"
                }
            },
            blobs: {
                serializedName: "manifest.blobs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BlobInfo"
                        }
                    }
                }
            },
            requestScope: {
                serializedName: "manifest.requestContext.requestScope",
                type: {
                    name: "String"
                }
            },
            requestBody: {
                serializedName: "manifest.requestContext.requestBody",
                type: {
                    name: "Composite",
                    className: "GenerateCostDetailsReportRequestDefinition"
                }
            }
        }
    }
};
const BlobInfo = {
    type: {
        name: "Composite",
        className: "BlobInfo",
        modelProperties: {
            blobLink: {
                serializedName: "blobLink",
                type: {
                    name: "String"
                }
            },
            byteCount: {
                serializedName: "byteCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const GenerateCostDetailsReportErrorResponse = {
    type: {
        name: "Composite",
        className: "GenerateCostDetailsReportErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            }
        }
    }
};
const GenerateDetailedCostReportDefinition = {
    type: {
        name: "Composite",
        className: "GenerateDetailedCostReportDefinition",
        modelProperties: {
            metric: {
                serializedName: "metric",
                type: {
                    name: "String"
                }
            },
            timePeriod: {
                serializedName: "timePeriod",
                type: {
                    name: "Composite",
                    className: "GenerateDetailedCostReportTimePeriod"
                }
            },
            billingPeriod: {
                serializedName: "billingPeriod",
                type: {
                    name: "String"
                }
            },
            invoiceId: {
                serializedName: "invoiceId",
                type: {
                    name: "String"
                }
            },
            customerId: {
                serializedName: "customerId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateDetailedCostReportTimePeriod = {
    type: {
        name: "Composite",
        className: "GenerateDetailedCostReportTimePeriod",
        modelProperties: {
            start: {
                serializedName: "start",
                required: true,
                type: {
                    name: "String"
                }
            },
            end: {
                serializedName: "end",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateDetailedCostReportOperationResult = {
    type: {
        name: "Composite",
        className: "GenerateDetailedCostReportOperationResult",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            expiryTime: {
                serializedName: "properties.expiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            validTill: {
                serializedName: "properties.validTill",
                type: {
                    name: "DateTime"
                }
            },
            downloadUrl: {
                serializedName: "properties.downloadUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DownloadURL = {
    type: {
        name: "Composite",
        className: "DownloadURL",
        modelProperties: {
            expiryTime: {
                serializedName: "expiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            validTill: {
                serializedName: "validTill",
                type: {
                    name: "DateTime"
                }
            },
            downloadUrl: {
                serializedName: "downloadUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateDetailedCostReportErrorResponse = {
    type: {
        name: "Composite",
        className: "GenerateDetailedCostReportErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            }
        }
    }
};
const GenerateDetailedCostReportOperationStatuses = {
    type: {
        name: "Composite",
        className: "GenerateDetailedCostReportOperationStatuses",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "Status"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            },
            expiryTime: {
                serializedName: "properties.expiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            validTill: {
                serializedName: "properties.validTill",
                type: {
                    name: "DateTime"
                }
            },
            downloadUrl: {
                serializedName: "properties.downloadUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Status = {
    type: {
        name: "Composite",
        className: "Status",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScheduledActionListResult = {
    type: {
        name: "Composite",
        className: "ScheduledActionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScheduledAction"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileDestination = {
    type: {
        name: "Composite",
        className: "FileDestination",
        modelProperties: {
            fileFormats: {
                serializedName: "fileFormats",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const NotificationProperties = {
    type: {
        name: "Composite",
        className: "NotificationProperties",
        modelProperties: {
            to: {
                constraints: {
                    MinItems: 1,
                    MaxItems: 20
                },
                serializedName: "to",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^[A-Za-z0-9._%+-]+@(?:[A-Za-z0-9-]+\\.)+[A-Za-z]{2,}$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            regionalFormat: {
                serializedName: "regionalFormat",
                type: {
                    name: "String"
                }
            },
            subject: {
                serializedName: "subject",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScheduleProperties = {
    type: {
        name: "Composite",
        className: "ScheduleProperties",
        modelProperties: {
            frequency: {
                serializedName: "frequency",
                required: true,
                type: {
                    name: "String"
                }
            },
            hourOfDay: {
                serializedName: "hourOfDay",
                type: {
                    name: "Number"
                }
            },
            daysOfWeek: {
                serializedName: "daysOfWeek",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            weeksOfMonth: {
                serializedName: "weeksOfMonth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dayOfMonth: {
                serializedName: "dayOfMonth",
                type: {
                    name: "Number"
                }
            },
            startDate: {
                serializedName: "startDate",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            endDate: {
                serializedName: "endDate",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponseWithNestedDetails = {
    type: {
        name: "Composite",
        className: "ErrorResponseWithNestedDetails",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetailsWithNestedDetails"
                }
            }
        }
    }
};
const CheckNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResponse = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResponse",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BenefitRecommendationsListResult = {
    type: {
        name: "Composite",
        className: "BenefitRecommendationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BenefitRecommendationModel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BenefitRecommendationProperties = {
    type: {
        name: "Composite",
        className: "BenefitRecommendationProperties",
        uberParent: "BenefitRecommendationProperties",
        polymorphicDiscriminator: {
            serializedName: "scope",
            clientName: "scope"
        },
        modelProperties: {
            firstConsumptionDate: {
                serializedName: "firstConsumptionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastConsumptionDate: {
                serializedName: "lastConsumptionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lookBackPeriod: {
                serializedName: "lookBackPeriod",
                type: {
                    name: "String"
                }
            },
            totalHours: {
                serializedName: "totalHours",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            usage: {
                serializedName: "usage",
                type: {
                    name: "Composite",
                    className: "RecommendationUsageDetails"
                }
            },
            armSkuName: {
                serializedName: "armSkuName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            term: {
                serializedName: "term",
                type: {
                    name: "String"
                }
            },
            commitmentGranularity: {
                serializedName: "commitmentGranularity",
                type: {
                    name: "String"
                }
            },
            currencyCode: {
                serializedName: "currencyCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            costWithoutBenefit: {
                serializedName: "costWithoutBenefit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            recommendationDetails: {
                serializedName: "recommendationDetails",
                type: {
                    name: "Composite",
                    className: "AllSavingsBenefitDetails"
                }
            },
            allRecommendationDetails: {
                serializedName: "allRecommendationDetails",
                type: {
                    name: "Composite",
                    className: "AllSavingsList"
                }
            },
            scope: {
                serializedName: "scope",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecommendationUsageDetails = {
    type: {
        name: "Composite",
        className: "RecommendationUsageDetails",
        modelProperties: {
            usageGrain: {
                serializedName: "usageGrain",
                type: {
                    name: "String"
                }
            },
            charges: {
                serializedName: "charges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const AllSavingsBenefitDetails = {
    type: {
        name: "Composite",
        className: "AllSavingsBenefitDetails",
        modelProperties: {
            overageCost: {
                serializedName: "overageCost",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            benefitCost: {
                serializedName: "benefitCost",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            totalCost: {
                serializedName: "totalCost",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            savingsAmount: {
                serializedName: "savingsAmount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            savingsPercentage: {
                serializedName: "savingsPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            coveragePercentage: {
                serializedName: "coveragePercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            commitmentAmount: {
                serializedName: "commitmentAmount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            averageUtilizationPercentage: {
                serializedName: "averageUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            wastageCost: {
                serializedName: "wastageCost",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AllSavingsList = {
    type: {
        name: "Composite",
        className: "AllSavingsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AllSavingsBenefitDetails"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BenefitUtilizationSummariesListResult = {
    type: {
        name: "Composite",
        className: "BenefitUtilizationSummariesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BenefitUtilizationSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BenefitUtilizationSummaryProperties = {
    type: {
        name: "Composite",
        className: "BenefitUtilizationSummaryProperties",
        modelProperties: {
            armSkuName: {
                serializedName: "armSkuName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            benefitId: {
                serializedName: "benefitId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            benefitOrderId: {
                serializedName: "benefitOrderId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            benefitType: {
                serializedName: "benefitType",
                type: {
                    name: "String"
                }
            },
            usageDate: {
                serializedName: "usageDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CostManagementOperation = {
    type: {
        name: "Composite",
        className: "CostManagementOperation",
        modelProperties: Object.assign(Object.assign({}, Operation.type.modelProperties), { id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ErrorDetailsWithNestedDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetailsWithNestedDetails",
        modelProperties: Object.assign(Object.assign({}, ErrorDetails.type.modelProperties), { details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetailsWithNestedDetails"
                        }
                    }
                }
            } })
    }
};
const View = {
    type: {
        name: "Composite",
        className: "View",
        modelProperties: Object.assign(Object.assign({}, CostManagementProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, modifiedOn: {
                serializedName: "properties.modifiedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, dateRange: {
                serializedName: "properties.dateRange",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, currency: {
                serializedName: "properties.currency",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, chart: {
                serializedName: "properties.chart",
                type: {
                    name: "String"
                }
            }, accumulated: {
                serializedName: "properties.accumulated",
                type: {
                    name: "String"
                }
            }, metric: {
                serializedName: "properties.metric",
                type: {
                    name: "String"
                }
            }, kpis: {
                serializedName: "properties.kpis",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiProperties"
                        }
                    }
                }
            }, pivots: {
                serializedName: "properties.pivots",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PivotProperties"
                        }
                    }
                }
            }, typePropertiesQueryType: {
                serializedName: "properties.query.type",
                type: {
                    name: "String"
                }
            }, timeframe: {
                serializedName: "properties.query.timeframe",
                type: {
                    name: "String"
                }
            }, timePeriod: {
                serializedName: "properties.query.timePeriod",
                type: {
                    name: "Composite",
                    className: "ReportConfigTimePeriod"
                }
            }, dataSet: {
                serializedName: "properties.query.dataSet",
                type: {
                    name: "Composite",
                    className: "ReportConfigDataset"
                }
            }, includeMonetaryCommitment: {
                serializedName: "properties.query.includeMonetaryCommitment",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const Alert = {
    type: {
        name: "Composite",
        className: "Alert",
        modelProperties: Object.assign(Object.assign({}, CostManagementProxyResource.type.modelProperties), { definition: {
                serializedName: "properties.definition",
                type: {
                    name: "Composite",
                    className: "AlertPropertiesDefinition"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, source: {
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            }, details: {
                serializedName: "properties.details",
                type: {
                    name: "Composite",
                    className: "AlertPropertiesDetails"
                }
            }, costEntityId: {
                serializedName: "properties.costEntityId",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                type: {
                    name: "String"
                }
            }, closeTime: {
                serializedName: "properties.closeTime",
                type: {
                    name: "String"
                }
            }, modificationTime: {
                serializedName: "properties.modificationTime",
                type: {
                    name: "String"
                }
            }, statusModificationUserName: {
                serializedName: "properties.statusModificationUserName",
                type: {
                    name: "String"
                }
            }, statusModificationTime: {
                serializedName: "properties.statusModificationTime",
                type: {
                    name: "String"
                }
            } })
    }
};
const ExportRun = {
    type: {
        name: "Composite",
        className: "ExportRun",
        modelProperties: Object.assign(Object.assign({}, CostManagementProxyResource.type.modelProperties), { executionType: {
                serializedName: "properties.executionType",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, submittedBy: {
                serializedName: "properties.submittedBy",
                type: {
                    name: "String"
                }
            }, submittedTime: {
                serializedName: "properties.submittedTime",
                type: {
                    name: "DateTime"
                }
            }, processingStartTime: {
                serializedName: "properties.processingStartTime",
                type: {
                    name: "DateTime"
                }
            }, processingEndTime: {
                serializedName: "properties.processingEndTime",
                type: {
                    name: "DateTime"
                }
            }, fileName: {
                serializedName: "properties.fileName",
                type: {
                    name: "String"
                }
            }, runSettings: {
                serializedName: "properties.runSettings",
                type: {
                    name: "Composite",
                    className: "CommonExportProperties"
                }
            }, error: {
                serializedName: "properties.error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            } })
    }
};
const Export = {
    type: {
        name: "Composite",
        className: "Export",
        modelProperties: Object.assign(Object.assign({}, CostManagementProxyResource.type.modelProperties), { format: {
                serializedName: "properties.format",
                type: {
                    name: "String"
                }
            }, deliveryInfo: {
                serializedName: "properties.deliveryInfo",
                type: {
                    name: "Composite",
                    className: "ExportDeliveryInfo"
                }
            }, definition: {
                serializedName: "properties.definition",
                type: {
                    name: "Composite",
                    className: "ExportDefinition"
                }
            }, runHistory: {
                serializedName: "properties.runHistory",
                type: {
                    name: "Composite",
                    className: "ExportExecutionListResult"
                }
            }, partitionData: {
                serializedName: "properties.partitionData",
                type: {
                    name: "Boolean"
                }
            }, nextRunTimeEstimate: {
                serializedName: "properties.nextRunTimeEstimate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, schedule: {
                serializedName: "properties.schedule",
                type: {
                    name: "Composite",
                    className: "ExportSchedule"
                }
            } })
    }
};
const ForecastResult = {
    type: {
        name: "Composite",
        className: "ForecastResult",
        modelProperties: Object.assign(Object.assign({}, CostManagementResource.type.modelProperties), { nextLink: {
                serializedName: "properties.nextLink",
                type: {
                    name: "String"
                }
            }, columns: {
                serializedName: "properties.columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ForecastColumn"
                        }
                    }
                }
            }, rows: {
                serializedName: "properties.rows",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "any"
                                }
                            }
                        }
                    }
                }
            } })
    }
};
const Dimension = {
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: Object.assign(Object.assign({}, CostManagementResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, filterEnabled: {
                serializedName: "properties.filterEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, groupingEnabled: {
                serializedName: "properties.groupingEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, total: {
                serializedName: "properties.total",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, category: {
                serializedName: "properties.category",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, usageStart: {
                serializedName: "properties.usageStart",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, usageEnd: {
                serializedName: "properties.usageEnd",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, nextLink: {
                serializedName: "properties.nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const QueryResult = {
    type: {
        name: "Composite",
        className: "QueryResult",
        modelProperties: Object.assign(Object.assign({}, CostManagementResource.type.modelProperties), { nextLink: {
                serializedName: "properties.nextLink",
                type: {
                    name: "String"
                }
            }, columns: {
                serializedName: "properties.columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryColumn"
                        }
                    }
                }
            }, rows: {
                serializedName: "properties.rows",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "any"
                                }
                            }
                        }
                    }
                }
            } })
    }
};
const ExportProperties = {
    type: {
        name: "Composite",
        className: "ExportProperties",
        modelProperties: Object.assign(Object.assign({}, CommonExportProperties.type.modelProperties), { schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "ExportSchedule"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const BenefitResource = {
    type: {
        name: "Composite",
        className: "BenefitResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            } })
    }
};
const BenefitUtilizationSummary = {
    serializedName: "BenefitUtilizationSummary",
    type: {
        name: "Composite",
        className: "BenefitUtilizationSummary",
        uberParent: "Resource",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SingleScopeBenefitRecommendationProperties = {
    serializedName: "Single",
    type: {
        name: "Composite",
        className: "SingleScopeBenefitRecommendationProperties",
        uberParent: "BenefitRecommendationProperties",
        polymorphicDiscriminator: BenefitRecommendationProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BenefitRecommendationProperties.type.modelProperties), { subscriptionId: {
                serializedName: "subscriptionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGroup: {
                serializedName: "resourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SharedScopeBenefitRecommendationProperties = {
    serializedName: "Shared",
    type: {
        name: "Composite",
        className: "SharedScopeBenefitRecommendationProperties",
        uberParent: "BenefitRecommendationProperties",
        polymorphicDiscriminator: BenefitRecommendationProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, BenefitRecommendationProperties.type.modelProperties)
    }
};
const IncludedQuantityUtilizationSummaryProperties = {
    type: {
        name: "Composite",
        className: "IncludedQuantityUtilizationSummaryProperties",
        modelProperties: Object.assign(Object.assign({}, BenefitUtilizationSummaryProperties.type.modelProperties), { utilizationPercentage: {
                serializedName: "utilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SavingsPlanUtilizationSummaryProperties = {
    type: {
        name: "Composite",
        className: "SavingsPlanUtilizationSummaryProperties",
        modelProperties: Object.assign(Object.assign({}, BenefitUtilizationSummaryProperties.type.modelProperties), { avgUtilizationPercentage: {
                serializedName: "avgUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, minUtilizationPercentage: {
                serializedName: "minUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, maxUtilizationPercentage: {
                serializedName: "maxUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ScheduledActionProxyResource = {
    type: {
        name: "Composite",
        className: "ScheduledActionProxyResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { eTag: {
                serializedName: "eTag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const BenefitRecommendationModel = {
    type: {
        name: "Composite",
        className: "BenefitRecommendationModel",
        modelProperties: Object.assign(Object.assign({}, BenefitResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BenefitRecommendationProperties"
                }
            } })
    }
};
const IncludedQuantityUtilizationSummary = {
    serializedName: "IncludedQuantity",
    type: {
        name: "Composite",
        className: "IncludedQuantityUtilizationSummary",
        uberParent: "BenefitUtilizationSummary",
        polymorphicDiscriminator: BenefitUtilizationSummary.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BenefitUtilizationSummary.type.modelProperties), { armSkuName: {
                serializedName: "properties.armSkuName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, benefitId: {
                serializedName: "properties.benefitId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, benefitOrderId: {
                serializedName: "properties.benefitOrderId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, benefitType: {
                serializedName: "properties.benefitType",
                type: {
                    name: "String"
                }
            }, usageDate: {
                serializedName: "properties.usageDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, utilizationPercentage: {
                serializedName: "properties.utilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SavingsPlanUtilizationSummary = {
    serializedName: "SavingsPlan",
    type: {
        name: "Composite",
        className: "SavingsPlanUtilizationSummary",
        uberParent: "BenefitUtilizationSummary",
        polymorphicDiscriminator: BenefitUtilizationSummary.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BenefitUtilizationSummary.type.modelProperties), { armSkuName: {
                serializedName: "properties.armSkuName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, benefitId: {
                serializedName: "properties.benefitId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, benefitOrderId: {
                serializedName: "properties.benefitOrderId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, benefitType: {
                serializedName: "properties.benefitType",
                type: {
                    name: "String"
                }
            }, usageDate: {
                serializedName: "properties.usageDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, avgUtilizationPercentage: {
                serializedName: "properties.avgUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, minUtilizationPercentage: {
                serializedName: "properties.minUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, maxUtilizationPercentage: {
                serializedName: "properties.maxUtilizationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ScheduledAction = {
    type: {
        name: "Composite",
        className: "ScheduledAction",
        modelProperties: Object.assign(Object.assign({}, ScheduledActionProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, fileDestination: {
                serializedName: "properties.fileDestination",
                type: {
                    name: "Composite",
                    className: "FileDestination"
                }
            }, notification: {
                serializedName: "properties.notification",
                type: {
                    name: "Composite",
                    className: "NotificationProperties"
                }
            }, notificationEmail: {
                serializedName: "properties.notificationEmail",
                type: {
                    name: "String"
                }
            }, schedule: {
                serializedName: "properties.schedule",
                type: {
                    name: "Composite",
                    className: "ScheduleProperties"
                }
            }, scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, viewId: {
                serializedName: "properties.viewId",
                type: {
                    name: "String"
                }
            } })
    }
};
const GenerateReservationDetailsReportByBillingAccountIdHeaders = {
    type: {
        name: "Composite",
        className: "GenerateReservationDetailsReportByBillingAccountIdHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const GenerateReservationDetailsReportByBillingProfileIdHeaders = {
    type: {
        name: "Composite",
        className: "GenerateReservationDetailsReportByBillingProfileIdHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const GenerateCostDetailsReportCreateOperationHeaders = {
    type: {
        name: "Composite",
        className: "GenerateCostDetailsReportCreateOperationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const GenerateDetailedCostReportCreateOperationHeaders = {
    type: {
        name: "Composite",
        className: "GenerateDetailedCostReportCreateOperationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureConsumptionAsyncOperation: {
                serializedName: "azure-consumption-asyncoperation",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PriceSheetDownloadHeaders = {
    type: {
        name: "Composite",
        className: "PriceSheetDownloadHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "String"
                }
            },
            oDataEntityId: {
                serializedName: "odata-entityid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PriceSheetDownloadByBillingProfileHeaders = {
    type: {
        name: "Composite",
        className: "PriceSheetDownloadByBillingProfileHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "String"
                }
            },
            oDataEntityId: {
                serializedName: "odata-entityid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    BenefitRecommendationProperties: BenefitRecommendationProperties,
    "Resource.BenefitUtilizationSummary": BenefitUtilizationSummary,
    "BenefitRecommendationProperties.Single": SingleScopeBenefitRecommendationProperties,
    "BenefitRecommendationProperties.Shared": SharedScopeBenefitRecommendationProperties,
    "BenefitUtilizationSummary.IncludedQuantity": IncludedQuantityUtilizationSummary,
    "BenefitUtilizationSummary.SavingsPlan": SavingsPlanUtilizationSummary
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ErrorResponse: ErrorResponse,
    ErrorDetails: ErrorDetails,
    ViewListResult: ViewListResult,
    ReportConfigTimePeriod: ReportConfigTimePeriod,
    ReportConfigDataset: ReportConfigDataset,
    ReportConfigDatasetConfiguration: ReportConfigDatasetConfiguration,
    ReportConfigAggregation: ReportConfigAggregation,
    ReportConfigGrouping: ReportConfigGrouping,
    ReportConfigSorting: ReportConfigSorting,
    ReportConfigFilter: ReportConfigFilter,
    ReportConfigComparisonExpression: ReportConfigComparisonExpression,
    KpiProperties: KpiProperties,
    PivotProperties: PivotProperties,
    CostManagementProxyResource: CostManagementProxyResource,
    AlertsResult: AlertsResult,
    AlertPropertiesDefinition: AlertPropertiesDefinition,
    AlertPropertiesDetails: AlertPropertiesDetails,
    DismissAlertPayload: DismissAlertPayload,
    ForecastDefinition: ForecastDefinition,
    ForecastTimePeriod: ForecastTimePeriod,
    ForecastDataset: ForecastDataset,
    ForecastDatasetConfiguration: ForecastDatasetConfiguration,
    ForecastAggregation: ForecastAggregation,
    ForecastFilter: ForecastFilter,
    ForecastComparisonExpression: ForecastComparisonExpression,
    ForecastColumn: ForecastColumn,
    CostManagementResource: CostManagementResource,
    DimensionsListResult: DimensionsListResult,
    QueryDefinition: QueryDefinition,
    QueryTimePeriod: QueryTimePeriod,
    QueryDataset: QueryDataset,
    QueryDatasetConfiguration: QueryDatasetConfiguration,
    QueryAggregation: QueryAggregation,
    QueryGrouping: QueryGrouping,
    QueryFilter: QueryFilter,
    QueryComparisonExpression: QueryComparisonExpression,
    QueryColumn: QueryColumn,
    OperationStatus: OperationStatus,
    ExportListResult: ExportListResult,
    ExportSchedule: ExportSchedule,
    ExportRecurrencePeriod: ExportRecurrencePeriod,
    CommonExportProperties: CommonExportProperties,
    ExportDeliveryInfo: ExportDeliveryInfo,
    ExportDeliveryDestination: ExportDeliveryDestination,
    ExportDefinition: ExportDefinition,
    ExportTimePeriod: ExportTimePeriod,
    ExportDataset: ExportDataset,
    ExportDatasetConfiguration: ExportDatasetConfiguration,
    ExportExecutionListResult: ExportExecutionListResult,
    GenerateCostDetailsReportRequestDefinition: GenerateCostDetailsReportRequestDefinition,
    CostDetailsTimePeriod: CostDetailsTimePeriod,
    CostDetailsOperationResults: CostDetailsOperationResults,
    BlobInfo: BlobInfo,
    GenerateCostDetailsReportErrorResponse: GenerateCostDetailsReportErrorResponse,
    GenerateDetailedCostReportDefinition: GenerateDetailedCostReportDefinition,
    GenerateDetailedCostReportTimePeriod: GenerateDetailedCostReportTimePeriod,
    GenerateDetailedCostReportOperationResult: GenerateDetailedCostReportOperationResult,
    DownloadURL: DownloadURL,
    GenerateDetailedCostReportErrorResponse: GenerateDetailedCostReportErrorResponse,
    GenerateDetailedCostReportOperationStatuses: GenerateDetailedCostReportOperationStatuses,
    Status: Status,
    ScheduledActionListResult: ScheduledActionListResult,
    FileDestination: FileDestination,
    NotificationProperties: NotificationProperties,
    ScheduleProperties: ScheduleProperties,
    SystemData: SystemData,
    Resource: Resource,
    ErrorResponseWithNestedDetails: ErrorResponseWithNestedDetails,
    CheckNameAvailabilityRequest: CheckNameAvailabilityRequest,
    CheckNameAvailabilityResponse: CheckNameAvailabilityResponse,
    BenefitRecommendationsListResult: BenefitRecommendationsListResult,
    BenefitRecommendationProperties: BenefitRecommendationProperties,
    RecommendationUsageDetails: RecommendationUsageDetails,
    AllSavingsBenefitDetails: AllSavingsBenefitDetails,
    AllSavingsList: AllSavingsList,
    BenefitUtilizationSummariesListResult: BenefitUtilizationSummariesListResult,
    BenefitUtilizationSummaryProperties: BenefitUtilizationSummaryProperties,
    CostManagementOperation: CostManagementOperation,
    ErrorDetailsWithNestedDetails: ErrorDetailsWithNestedDetails,
    View: View,
    Alert: Alert,
    ExportRun: ExportRun,
    Export: Export,
    ForecastResult: ForecastResult,
    Dimension: Dimension,
    QueryResult: QueryResult,
    ExportProperties: ExportProperties,
    ProxyResource: ProxyResource,
    BenefitResource: BenefitResource,
    BenefitUtilizationSummary: BenefitUtilizationSummary,
    SingleScopeBenefitRecommendationProperties: SingleScopeBenefitRecommendationProperties,
    SharedScopeBenefitRecommendationProperties: SharedScopeBenefitRecommendationProperties,
    IncludedQuantityUtilizationSummaryProperties: IncludedQuantityUtilizationSummaryProperties,
    SavingsPlanUtilizationSummaryProperties: SavingsPlanUtilizationSummaryProperties,
    ScheduledActionProxyResource: ScheduledActionProxyResource,
    BenefitRecommendationModel: BenefitRecommendationModel,
    IncludedQuantityUtilizationSummary: IncludedQuantityUtilizationSummary,
    SavingsPlanUtilizationSummary: SavingsPlanUtilizationSummary,
    ScheduledAction: ScheduledAction,
    GenerateReservationDetailsReportByBillingAccountIdHeaders: GenerateReservationDetailsReportByBillingAccountIdHeaders,
    GenerateReservationDetailsReportByBillingProfileIdHeaders: GenerateReservationDetailsReportByBillingProfileIdHeaders,
    GenerateCostDetailsReportCreateOperationHeaders: GenerateCostDetailsReportCreateOperationHeaders,
    GenerateDetailedCostReportCreateOperationHeaders: GenerateDetailedCostReportCreateOperationHeaders,
    PriceSheetDownloadHeaders: PriceSheetDownloadHeaders,
    PriceSheetDownloadByBillingProfileHeaders: PriceSheetDownloadByBillingProfileHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    }
};
const viewName = {
    parameterPath: "viewName",
    mapper: {
        serializedName: "viewName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: View
};
const scope1 = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const alertId = {
    parameterPath: "alertId",
    mapper: {
        serializedName: "alertId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: DismissAlertPayload
};
const externalCloudProviderType = {
    parameterPath: "externalCloudProviderType",
    mapper: {
        serializedName: "externalCloudProviderType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const externalCloudProviderId = {
    parameterPath: "externalCloudProviderId",
    mapper: {
        serializedName: "externalCloudProviderId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ForecastDefinition
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const skiptoken = {
    parameterPath: ["options", "skiptoken"],
    mapper: {
        serializedName: "$skiptoken",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        constraints: {
            InclusiveMaximum: 1000,
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: QueryDefinition
};
const billingAccountId = {
    parameterPath: "billingAccountId",
    mapper: {
        serializedName: "billingAccountId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const startDate = {
    parameterPath: "startDate",
    mapper: {
        serializedName: "startDate",
        required: true,
        type: {
            name: "String"
        }
    }
};
const endDate = {
    parameterPath: "endDate",
    mapper: {
        serializedName: "endDate",
        required: true,
        type: {
            name: "String"
        }
    }
};
const billingProfileId = {
    parameterPath: "billingProfileId",
    mapper: {
        serializedName: "billingProfileId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const exportName = {
    parameterPath: "exportName",
    mapper: {
        serializedName: "exportName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: Export
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: GenerateCostDetailsReportRequestDefinition
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: GenerateDetailedCostReportDefinition
};
const billingAccountName = {
    parameterPath: "billingAccountName",
    mapper: {
        constraints: {
            Pattern: new RegExp("([A-Za-z0-9]+(-[A-Za-z0-9]+)+):([A-Za-z0-9]+(-[A-Za-z0-9]+)+)_[0-9]{4}-[0-9]{2}-[0-9]{2}")
        },
        serializedName: "billingAccountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const billingProfileName = {
    parameterPath: "billingProfileName",
    mapper: {
        constraints: {
            Pattern: new RegExp("([A-Za-z0-9]+(-[A-Za-z0-9]+)+)")
        },
        serializedName: "billingProfileName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const invoiceName = {
    parameterPath: "invoiceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("[A-Za-z0-9]+")
        },
        serializedName: "invoiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scheduledAction = {
    parameterPath: "scheduledAction",
    mapper: ScheduledAction
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const checkNameAvailabilityRequest = {
    parameterPath: "checkNameAvailabilityRequest",
    mapper: CheckNameAvailabilityRequest
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "String"
        }
    }
};
const billingScope = {
    parameterPath: "billingScope",
    mapper: {
        serializedName: "billingScope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const grainParameter = {
    parameterPath: ["options", "grainParameter"],
    mapper: {
        serializedName: "grainParameter",
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "filter",
        type: {
            name: "String"
        }
    }
};
const savingsPlanOrderId = {
    parameterPath: "savingsPlanOrderId",
    mapper: {
        serializedName: "savingsPlanOrderId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const savingsPlanId = {
    parameterPath: "savingsPlanId",
    mapper: {
        serializedName: "savingsPlanId",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available cost management REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available cost management REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/providers/Microsoft.CostManagement/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Views operations. */
class ViewsImpl {
    /**
     * Initialize a new instance of the class Views class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all views by tenant and object.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all views at the given scope.
     * @param scope The scope associated with view operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     *              Management Group scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope.
     * @param options The options parameters.
     */
    listByScope(scope, options) {
        const iter = this.listByScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByScopePagingPage(scope, options, settings);
            }
        };
    }
    listByScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByScopePagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByScopePagingPage(scope, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all views by tenant and object.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * Lists all views at the given scope.
     * @param scope The scope associated with view operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     *              Management Group scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope.
     * @param options The options parameters.
     */
    _listByScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listByScopeOperationSpec$1);
    }
    /**
     * Gets the view by view name.
     * @param viewName View name
     * @param options The options parameters.
     */
    get(viewName, options) {
        return this.client.sendOperationRequest({ viewName, options }, getOperationSpec$5);
    }
    /**
     * The operation to create or update a view. Update operation requires latest eTag to be set in the
     * request. You may obtain the latest eTag by performing a get operation. Create operation does not
     * require eTag.
     * @param viewName View name
     * @param parameters Parameters supplied to the CreateOrUpdate View operation.
     * @param options The options parameters.
     */
    createOrUpdate(viewName, parameters, options) {
        return this.client.sendOperationRequest({ viewName, parameters, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * The operation to delete a view.
     * @param viewName View name
     * @param options The options parameters.
     */
    delete(viewName, options) {
        return this.client.sendOperationRequest({ viewName, options }, deleteOperationSpec$2);
    }
    /**
     * Gets the view for the defined scope by view name.
     * @param scope The scope associated with view operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     *              Management Group scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope.
     * @param viewName View name
     * @param options The options parameters.
     */
    getByScope(scope, viewName, options) {
        return this.client.sendOperationRequest({ scope, viewName, options }, getByScopeOperationSpec$1);
    }
    /**
     * The operation to create or update a view. Update operation requires latest eTag to be set in the
     * request. You may obtain the latest eTag by performing a get operation. Create operation does not
     * require eTag.
     * @param scope The scope associated with view operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     *              Management Group scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope.
     * @param viewName View name
     * @param parameters Parameters supplied to the CreateOrUpdate View operation.
     * @param options The options parameters.
     */
    createOrUpdateByScope(scope, viewName, parameters, options) {
        return this.client.sendOperationRequest({ scope, viewName, parameters, options }, createOrUpdateByScopeOperationSpec$1);
    }
    /**
     * The operation to delete a view.
     * @param scope The scope associated with view operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     *              Management Group scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope.
     * @param viewName View name
     * @param options The options parameters.
     */
    deleteByScope(scope, viewName, options) {
        return this.client.sendOperationRequest({ scope, viewName, options }, deleteByScopeOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListByScopeNext
     * @param scope The scope associated with view operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     *              Management Group scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope.
     * @param nextLink The nextLink from the previous successful call to the ListByScope method.
     * @param options The options parameters.
     */
    _listByScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listByScopeNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/providers/Microsoft.CostManagement/views",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/views",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$5 = {
    path: "/providers/Microsoft.CostManagement/views/{viewName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: View
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, viewName],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$2 = {
    path: "/providers/Microsoft.CostManagement/views/{viewName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: View
        },
        201: {
            bodyMapper: View
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [$host, viewName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$2 = {
    path: "/providers/Microsoft.CostManagement/views/{viewName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, viewName],
    headerParameters: [accept],
    serializer: serializer$e
};
const getByScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/views/{viewName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: View
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, viewName],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateByScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/views/{viewName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: View
        },
        201: {
            bodyMapper: View
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, viewName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteByScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/views/{viewName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, viewName],
    headerParameters: [accept],
    serializer: serializer$e
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Alerts operations. */
class AlertsImpl {
    /**
     * Initialize a new instance of the class Alerts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the alerts for scope defined.
     * @param scope The scope associated with alerts operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param options The options parameters.
     */
    list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$4);
    }
    /**
     * Gets the alert for the scope by alert ID.
     * @param scope The scope associated with alerts operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param alertId Alert ID
     * @param options The options parameters.
     */
    get(scope, alertId, options) {
        return this.client.sendOperationRequest({ scope, alertId, options }, getOperationSpec$4);
    }
    /**
     * Dismisses the specified alert
     * @param scope The scope associated with alerts operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param alertId Alert ID
     * @param parameters Parameters supplied to the Dismiss Alert operation.
     * @param options The options parameters.
     */
    dismiss(scope, alertId, parameters, options) {
        return this.client.sendOperationRequest({ scope, alertId, parameters, options }, dismissOperationSpec);
    }
    /**
     * Lists the Alerts for external cloud provider type defined.
     * @param externalCloudProviderType The external cloud provider type associated with dimension/query
     *                                  operations. This includes 'externalSubscriptions' for linked account and 'externalBillingAccounts'
     *                                  for consolidated account.
     * @param externalCloudProviderId This can be '{externalSubscriptionId}' for linked account or
     *                                '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
     * @param options The options parameters.
     */
    listExternal(externalCloudProviderType, externalCloudProviderId, options) {
        return this.client.sendOperationRequest({ externalCloudProviderType, externalCloudProviderId, options }, listExternalOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/{scope}/providers/Microsoft.CostManagement/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertsResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$4 = {
    path: "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Alert
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, alertId],
    headerParameters: [accept],
    serializer: serializer$d
};
const dismissOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Alert
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, alertId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const listExternalOperationSpec = {
    path: "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertsResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        externalCloudProviderType,
        externalCloudProviderId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Forecast operations. */
class ForecastImpl {
    /**
     * Initialize a new instance of the class Forecast class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the forecast charges for scope defined.
     * @param scope The scope associated with forecast operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param parameters Parameters supplied to the CreateOrUpdate Forecast Config operation.
     * @param options The options parameters.
     */
    usage(scope, parameters, options) {
        return this.client.sendOperationRequest({ scope, parameters, options }, usageOperationSpec$1);
    }
    /**
     * Lists the forecast charges for external cloud provider type defined.
     * @param externalCloudProviderType The external cloud provider type associated with dimension/query
     *                                  operations. This includes 'externalSubscriptions' for linked account and 'externalBillingAccounts'
     *                                  for consolidated account.
     * @param externalCloudProviderId This can be '{externalSubscriptionId}' for linked account or
     *                                '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
     * @param parameters Parameters supplied to the CreateOrUpdate Forecast Config operation.
     * @param options The options parameters.
     */
    externalCloudProviderUsage(externalCloudProviderType, externalCloudProviderId, parameters, options) {
        return this.client.sendOperationRequest({
            externalCloudProviderType,
            externalCloudProviderId,
            parameters,
            options
        }, externalCloudProviderUsageOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const usageOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/forecast",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ForecastResult
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, scope1],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const externalCloudProviderUsageOperationSpec = {
    path: "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ForecastResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        externalCloudProviderType,
        externalCloudProviderId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Dimensions operations. */
class DimensionsImpl {
    /**
     * Initialize a new instance of the class Dimensions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the dimensions by the defined scope.
     * @param scope The scope associated with dimension operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}'
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific for
     *              partners.
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.listPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(scope, options, settings);
            }
        };
    }
    listPagingPage(scope, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(scope, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(scope, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the dimensions by the external cloud provider type.
     * @param externalCloudProviderType The external cloud provider type associated with dimension/query
     *                                  operations. This includes 'externalSubscriptions' for linked account and 'externalBillingAccounts'
     *                                  for consolidated account.
     * @param externalCloudProviderId This can be '{externalSubscriptionId}' for linked account or
     *                                '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
     * @param options The options parameters.
     */
    listByExternalCloudProviderType(externalCloudProviderType, externalCloudProviderId, options) {
        const iter = this.byExternalCloudProviderTypePagingAll(externalCloudProviderType, externalCloudProviderId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.byExternalCloudProviderTypePagingPage(externalCloudProviderType, externalCloudProviderId, options, settings);
            }
        };
    }
    byExternalCloudProviderTypePagingPage(externalCloudProviderType, externalCloudProviderId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* byExternalCloudProviderTypePagingPage_1() {
            let result;
            result = yield tslib.__await(this._byExternalCloudProviderType(externalCloudProviderType, externalCloudProviderId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    byExternalCloudProviderTypePagingAll(externalCloudProviderType, externalCloudProviderId, options) {
        return tslib.__asyncGenerator(this, arguments, function* byExternalCloudProviderTypePagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.byExternalCloudProviderTypePagingPage(externalCloudProviderType, externalCloudProviderId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the dimensions by the defined scope.
     * @param scope The scope associated with dimension operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}'
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific for
     *              partners.
     * @param options The options parameters.
     */
    _list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$3);
    }
    /**
     * Lists the dimensions by the external cloud provider type.
     * @param externalCloudProviderType The external cloud provider type associated with dimension/query
     *                                  operations. This includes 'externalSubscriptions' for linked account and 'externalBillingAccounts'
     *                                  for consolidated account.
     * @param externalCloudProviderId This can be '{externalSubscriptionId}' for linked account or
     *                                '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
     * @param options The options parameters.
     */
    _byExternalCloudProviderType(externalCloudProviderType, externalCloudProviderId, options) {
        return this.client.sendOperationRequest({ externalCloudProviderType, externalCloudProviderId, options }, byExternalCloudProviderTypeOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.CostManagement/dimensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DimensionsListResult
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expand,
        skiptoken,
        top
    ],
    urlParameters: [$host, scope1],
    headerParameters: [accept],
    serializer: serializer$b
};
const byExternalCloudProviderTypeOperationSpec = {
    path: "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DimensionsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expand,
        skiptoken,
        top
    ],
    urlParameters: [
        $host,
        externalCloudProviderType,
        externalCloudProviderId
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Query operations. */
class QueryImpl {
    /**
     * Initialize a new instance of the class Query class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Query the usage data for scope defined.
     * @param scope The scope associated with query and export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param parameters Parameters supplied to the CreateOrUpdate Query Config operation.
     * @param options The options parameters.
     */
    usage(scope, parameters, options) {
        return this.client.sendOperationRequest({ scope, parameters, options }, usageOperationSpec);
    }
    /**
     * Query the usage data for external cloud provider type defined.
     * @param externalCloudProviderType The external cloud provider type associated with dimension/query
     *                                  operations. This includes 'externalSubscriptions' for linked account and 'externalBillingAccounts'
     *                                  for consolidated account.
     * @param externalCloudProviderId This can be '{externalSubscriptionId}' for linked account or
     *                                '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
     * @param parameters Parameters supplied to the CreateOrUpdate Query Config operation.
     * @param options The options parameters.
     */
    usageByExternalCloudProviderType(externalCloudProviderType, externalCloudProviderId, parameters, options) {
        return this.client.sendOperationRequest({
            externalCloudProviderType,
            externalCloudProviderId,
            parameters,
            options
        }, usageByExternalCloudProviderTypeOperationSpec);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const usageOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResult
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const usageByExternalCloudProviderTypeOperationSpec = {
    path: "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        externalCloudProviderType,
        externalCloudProviderId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GenerateReservationDetailsReport operations. */
class GenerateReservationDetailsReportImpl {
    /**
     * Initialize a new instance of the class GenerateReservationDetailsReport class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Generates the reservations details report for provided date range asynchronously based on enrollment
     * id. The Reservation usage details can be viewed only by certain enterprise roles. For more details
     * on the roles see,
     * https://docs.microsoft.com/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role
     * @param billingAccountId Enrollment ID (Legacy BillingAccount ID)
     * @param startDate Start Date
     * @param endDate End Date
     * @param options The options parameters.
     */
    beginByBillingAccountId(billingAccountId, startDate, endDate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { billingAccountId, startDate, endDate, options },
                spec: byBillingAccountIdOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates the reservations details report for provided date range asynchronously based on enrollment
     * id. The Reservation usage details can be viewed only by certain enterprise roles. For more details
     * on the roles see,
     * https://docs.microsoft.com/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role
     * @param billingAccountId Enrollment ID (Legacy BillingAccount ID)
     * @param startDate Start Date
     * @param endDate End Date
     * @param options The options parameters.
     */
    beginByBillingAccountIdAndWait(billingAccountId, startDate, endDate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginByBillingAccountId(billingAccountId, startDate, endDate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates the reservations details report for provided date range asynchronously by billing profile.
     * The Reservation usage details can be viewed by only certain enterprise roles by default. For more
     * details on the roles see,
     * https://docs.microsoft.com/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access
     * @param billingAccountId Billing account ID
     * @param billingProfileId Billing profile ID.
     * @param startDate Start Date
     * @param endDate End Date
     * @param options The options parameters.
     */
    beginByBillingProfileId(billingAccountId, billingProfileId, startDate, endDate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { billingAccountId, billingProfileId, startDate, endDate, options },
                spec: byBillingProfileIdOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates the reservations details report for provided date range asynchronously by billing profile.
     * The Reservation usage details can be viewed by only certain enterprise roles by default. For more
     * details on the roles see,
     * https://docs.microsoft.com/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access
     * @param billingAccountId Billing account ID
     * @param billingProfileId Billing profile ID.
     * @param startDate Start Date
     * @param endDate End Date
     * @param options The options parameters.
     */
    beginByBillingProfileIdAndWait(billingAccountId, billingProfileId, startDate, endDate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginByBillingProfileId(billingAccountId, billingProfileId, startDate, endDate, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const byBillingAccountIdOperationSpec = {
    path: "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationStatus
        },
        201: {
            bodyMapper: OperationStatus
        },
        202: {
            bodyMapper: OperationStatus
        },
        204: {
            bodyMapper: OperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startDate,
        endDate
    ],
    urlParameters: [$host, billingAccountId],
    headerParameters: [accept],
    serializer: serializer$9
};
const byBillingProfileIdOperationSpec = {
    path: "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationStatus
        },
        201: {
            bodyMapper: OperationStatus
        },
        202: {
            bodyMapper: OperationStatus
        },
        204: {
            bodyMapper: OperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        startDate,
        endDate
    ],
    urlParameters: [
        $host,
        billingAccountId,
        billingProfileId
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Exports operations. */
class ExportsImpl {
    /**
     * Initialize a new instance of the class Exports class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The operation to list all exports at the given scope.
     * @param scope The scope associated with export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param options The options parameters.
     */
    list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$2);
    }
    /**
     * The operation to get the export for the defined scope by export name.
     * @param scope The scope associated with export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param exportName Export Name.
     * @param options The options parameters.
     */
    get(scope, exportName, options) {
        return this.client.sendOperationRequest({ scope, exportName, options }, getOperationSpec$3);
    }
    /**
     * The operation to create or update a export. Update operation requires latest eTag to be set in the
     * request. You may obtain the latest eTag by performing a get operation. Create operation does not
     * require eTag.
     * @param scope The scope associated with export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param exportName Export Name.
     * @param parameters Parameters supplied to the CreateOrUpdate Export operation.
     * @param options The options parameters.
     */
    createOrUpdate(scope, exportName, parameters, options) {
        return this.client.sendOperationRequest({ scope, exportName, parameters, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * The operation to delete a export.
     * @param scope The scope associated with export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param exportName Export Name.
     * @param options The options parameters.
     */
    delete(scope, exportName, options) {
        return this.client.sendOperationRequest({ scope, exportName, options }, deleteOperationSpec$1);
    }
    /**
     * The operation to run an export.
     * @param scope The scope associated with export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param exportName Export Name.
     * @param options The options parameters.
     */
    execute(scope, exportName, options) {
        return this.client.sendOperationRequest({ scope, exportName, options }, executeOperationSpec);
    }
    /**
     * The operation to get the run history of an export for the defined scope and export name.
     * @param scope The scope associated with export operations. This includes
     *              '/subscriptions/{subscriptionId}/' for subscription scope,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope, '/providers/Microsoft.Management/managementGroups/{managementGroupId}
     *              for Management Group scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for billingProfile scope,
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
     *              for invoiceSection scope, and
     *              '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}' specific
     *              for partners.
     * @param exportName Export Name.
     * @param options The options parameters.
     */
    getExecutionHistory(scope, exportName, options) {
        return this.client.sendOperationRequest({ scope, exportName, options }, getExecutionHistoryOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.CostManagement/exports",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExportListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, scope1],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Export
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, scope1, exportName],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Export
        },
        201: {
            bodyMapper: Export
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, exportName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, exportName],
    headerParameters: [accept],
    serializer: serializer$8
};
const executeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, exportName],
    headerParameters: [accept],
    serializer: serializer$8
};
const getExecutionHistoryOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExportExecutionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, exportName],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GenerateCostDetailsReport operations. */
class GenerateCostDetailsReportImpl {
    /**
     * Initialize a new instance of the class GenerateCostDetailsReport class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This API is the replacement for all previously release Usage Details APIs. Request to generate a
     * cost details report for the provided date range, billing period (Only enterprise customers) or
     * Invoice Id asynchronously at a certain scope. The initial call to request a report will return a 202
     * with a 'Location' and 'Retry-After' header. The 'Location' header will provide the endpoint to poll
     * to get the result of the report generation. The 'Retry-After' provides the duration to wait before
     * polling for the generated report. A call to poll the report operation will provide a 202 response
     * with a 'Location' header if the operation is still in progress. Once the report generation operation
     * completes, the polling endpoint will provide a 200 response along with details on the report blob(s)
     * that are available for download. The details on the file(s) available for download will be available
     * in the polling response body. To Understand cost details (formerly known as usage details) fields
     * found in files ,see
     * https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param parameters Parameters supplied to the Create cost details operation.
     * @param options The options parameters.
     */
    beginCreateOperation(scope, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { scope, parameters, options },
                spec: createOperationOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This API is the replacement for all previously release Usage Details APIs. Request to generate a
     * cost details report for the provided date range, billing period (Only enterprise customers) or
     * Invoice Id asynchronously at a certain scope. The initial call to request a report will return a 202
     * with a 'Location' and 'Retry-After' header. The 'Location' header will provide the endpoint to poll
     * to get the result of the report generation. The 'Retry-After' provides the duration to wait before
     * polling for the generated report. A call to poll the report operation will provide a 202 response
     * with a 'Location' header if the operation is still in progress. Once the report generation operation
     * completes, the polling endpoint will provide a 200 response along with details on the report blob(s)
     * that are available for download. The details on the file(s) available for download will be available
     * in the polling response body. To Understand cost details (formerly known as usage details) fields
     * found in files ,see
     * https://learn.microsoft.com/azure/cost-management-billing/automate/understand-usage-details-fields
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param parameters Parameters supplied to the Create cost details operation.
     * @param options The options parameters.
     */
    beginCreateOperationAndWait(scope, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOperation(scope, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the result of the specified operation. This link is provided in the CostDetails creation request
     * response Location header.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param operationId The target operation Id.
     * @param options The options parameters.
     */
    beginGetOperationResults(scope, operationId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { scope, operationId, options },
                spec: getOperationResultsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Get the result of the specified operation. This link is provided in the CostDetails creation request
     * response Location header.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param operationId The target operation Id.
     * @param options The options parameters.
     */
    beginGetOperationResultsAndWait(scope, operationId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetOperationResults(scope, operationId, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/generateCostDetailsReport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CostDetailsOperationResults
        },
        201: {
            bodyMapper: CostDetailsOperationResults
        },
        202: {
            bodyMapper: CostDetailsOperationResults
        },
        204: {
            bodyMapper: CostDetailsOperationResults
        },
        default: {
            bodyMapper: GenerateCostDetailsReportErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const getOperationResultsOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/costDetailsOperationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CostDetailsOperationResults
        },
        201: {
            bodyMapper: CostDetailsOperationResults
        },
        202: {
            bodyMapper: CostDetailsOperationResults
        },
        204: {
            bodyMapper: CostDetailsOperationResults
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, operationId],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GenerateDetailedCostReport operations. */
class GenerateDetailedCostReportImpl {
    /**
     * Initialize a new instance of the class GenerateDetailedCostReport class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Generates the detailed cost report for provided date range, billing period(only enterprise
     * customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
     * Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the operation
     * will provide the status and if the operation is completed the blob file where generated detailed
     * cost report is being stored.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param parameters Parameters supplied to the Create detailed cost report operation.
     * @param options The options parameters.
     */
    beginCreateOperation(scope, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { scope, parameters, options },
                spec: createOperationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates the detailed cost report for provided date range, billing period(only enterprise
     * customers) or Invoice ID asynchronously at a certain scope. Call returns a 202 with header
     * Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the operation
     * will provide the status and if the operation is completed the blob file where generated detailed
     * cost report is being stored.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param parameters Parameters supplied to the Create detailed cost report operation.
     * @param options The options parameters.
     */
    beginCreateOperationAndWait(scope, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOperation(scope, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        201: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        202: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        204: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        default: {
            bodyMapper: GenerateDetailedCostReportErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GenerateDetailedCostReportOperationResults operations. */
class GenerateDetailedCostReportOperationResultsImpl {
    /**
     * Initialize a new instance of the class GenerateDetailedCostReportOperationResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the result of the specified operation. The link with this operationId is provided as a response
     * header of the initial request.
     * @param operationId The target operation Id.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param options The options parameters.
     */
    beginGet(operationId, scope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { operationId, scope, options },
                spec: getOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the result of the specified operation. The link with this operationId is provided as a response
     * header of the initial request.
     * @param operationId The target operation Id.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param options The options parameters.
     */
    beginGetAndWait(operationId, scope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGet(operationId, scope, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        201: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        202: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        204: {
            bodyMapper: GenerateDetailedCostReportOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, operationId],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GenerateDetailedCostReportOperationStatus operations. */
class GenerateDetailedCostReportOperationStatusImpl {
    /**
     * Initialize a new instance of the class GenerateDetailedCostReportOperationStatus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the status of the specified operation. This link is provided in the GenerateDetailedCostReport
     * creation request response header.
     * @param operationId The target operation Id.
     * @param scope The ARM Resource ID for subscription, resource group, billing account, or other billing
     *              scopes. For details, see https://aka.ms/costmgmt/scopes.
     * @param options The options parameters.
     */
    get(operationId, scope, options) {
        return this.client.sendOperationRequest({ operationId, scope, options }, getOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GenerateDetailedCostReportOperationStatuses
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1, operationId],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PriceSheet operations. */
class PriceSheetImpl {
    /**
     * Initialize a new instance of the class PriceSheet class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a URL to download the pricesheet for an invoice. The operation is supported for billing
     * accounts with agreement type Microsoft Partner Agreement or Microsoft Customer Agreement.
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceName The ID that uniquely identifies an invoice.
     * @param options The options parameters.
     */
    beginDownload(billingAccountName, billingProfileName, invoiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { billingAccountName, billingProfileName, invoiceName, options },
                spec: downloadOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets a URL to download the pricesheet for an invoice. The operation is supported for billing
     * accounts with agreement type Microsoft Partner Agreement or Microsoft Customer Agreement.
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param invoiceName The ID that uniquely identifies an invoice.
     * @param options The options parameters.
     */
    beginDownloadAndWait(billingAccountName, billingProfileName, invoiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDownload(billingAccountName, billingProfileName, invoiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a URL to download the current month's pricesheet for a billing profile. The operation is
     * supported for billing accounts with agreement type Microsoft Partner Agreement or Microsoft Customer
     * Agreement.Due to Azure product growth, the Azure price sheet download experience in this preview
     * version will be updated from a single csv file to a Zip file containing multiple csv files, each
     * with max 200k records.
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param options The options parameters.
     */
    beginDownloadByBillingProfile(billingAccountName, billingProfileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { billingAccountName, billingProfileName, options },
                spec: downloadByBillingProfileOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets a URL to download the current month's pricesheet for a billing profile. The operation is
     * supported for billing accounts with agreement type Microsoft Partner Agreement or Microsoft Customer
     * Agreement.Due to Azure product growth, the Azure price sheet download experience in this preview
     * version will be updated from a single csv file to a Zip file containing multiple csv files, each
     * with max 200k records.
     * @param billingAccountName The ID that uniquely identifies a billing account.
     * @param billingProfileName The ID that uniquely identifies a billing profile.
     * @param options The options parameters.
     */
    beginDownloadByBillingProfileAndWait(billingAccountName, billingProfileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDownloadByBillingProfile(billingAccountName, billingProfileName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const downloadOperationSpec = {
    path: "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/invoices/{invoiceName}/providers/Microsoft.CostManagement/pricesheets/default/download",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DownloadURL
        },
        201: {
            bodyMapper: DownloadURL
        },
        202: {
            bodyMapper: DownloadURL
        },
        204: {
            bodyMapper: DownloadURL
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        billingAccountName,
        billingProfileName,
        invoiceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const downloadByBillingProfileOperationSpec = {
    path: "/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/providers/Microsoft.CostManagement/pricesheets/default/download",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DownloadURL
        },
        201: {
            bodyMapper: DownloadURL
        },
        202: {
            bodyMapper: DownloadURL
        },
        204: {
            bodyMapper: DownloadURL
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        billingAccountName,
        billingProfileName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScheduledActions operations. */
class ScheduledActionsImpl {
    /**
     * Initialize a new instance of the class ScheduledActions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all private scheduled actions.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all shared scheduled actions within the given scope.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param options The options parameters.
     */
    listByScope(scope, options) {
        const iter = this.listByScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByScopePagingPage(scope, options, settings);
            }
        };
    }
    listByScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByScopePagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByScopePagingPage(scope, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all private scheduled actions.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * List all shared scheduled actions within the given scope.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param options The options parameters.
     */
    _listByScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listByScopeOperationSpec);
    }
    /**
     * Create or update a private scheduled action.
     * @param name Scheduled action name.
     * @param scheduledAction Scheduled action to be created or updated.
     * @param options The options parameters.
     */
    createOrUpdate(name, scheduledAction, options) {
        return this.client.sendOperationRequest({ name, scheduledAction, options }, createOrUpdateOperationSpec);
    }
    /**
     * Get the private scheduled action by name.
     * @param name Scheduled action name.
     * @param options The options parameters.
     */
    get(name, options) {
        return this.client.sendOperationRequest({ name, options }, getOperationSpec);
    }
    /**
     * Delete a private scheduled action.
     * @param name Scheduled action name.
     * @param options The options parameters.
     */
    delete(name, options) {
        return this.client.sendOperationRequest({ name, options }, deleteOperationSpec);
    }
    /**
     * Create or update a shared scheduled action within the given scope.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param name Scheduled action name.
     * @param scheduledAction Scheduled action to be created or updated.
     * @param options The options parameters.
     */
    createOrUpdateByScope(scope, name, scheduledAction, options) {
        return this.client.sendOperationRequest({ scope, name, scheduledAction, options }, createOrUpdateByScopeOperationSpec);
    }
    /**
     * Get the shared scheduled action from the given scope by name.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param name Scheduled action name.
     * @param options The options parameters.
     */
    getByScope(scope, name, options) {
        return this.client.sendOperationRequest({ scope, name, options }, getByScopeOperationSpec);
    }
    /**
     * Delete a scheduled action within the given scope.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param name Scheduled action name.
     * @param options The options parameters.
     */
    deleteByScope(scope, name, options) {
        return this.client.sendOperationRequest({ scope, name, options }, deleteByScopeOperationSpec);
    }
    /**
     * Processes a private scheduled action.
     * @param name Scheduled action name.
     * @param options The options parameters.
     */
    run(name, options) {
        return this.client.sendOperationRequest({ name, options }, runOperationSpec);
    }
    /**
     * Runs a shared scheduled action within the given scope.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param name Scheduled action name.
     * @param options The options parameters.
     */
    runByScope(scope, name, options) {
        return this.client.sendOperationRequest({ scope, name, options }, runByScopeOperationSpec);
    }
    /**
     * Checks availability and correctness of the name for a scheduled action.
     * @param checkNameAvailabilityRequest Scheduled action to be created or updated.
     * @param options The options parameters.
     */
    checkNameAvailability(checkNameAvailabilityRequest, options) {
        return this.client.sendOperationRequest({ checkNameAvailabilityRequest, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Checks availability and correctness of the name for a scheduled action within the given scope.
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param checkNameAvailabilityRequest Scheduled action to be created or updated.
     * @param options The options parameters.
     */
    checkNameAvailabilityByScope(scope, checkNameAvailabilityRequest, options) {
        return this.client.sendOperationRequest({ scope, checkNameAvailabilityRequest, options }, checkNameAvailabilityByScopeOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
    /**
     * ListByScopeNext
     * @param scope The scope associated with scheduled action operations. This includes
     *              'subscriptions/{subscriptionId}' for subscription scope,
     *              'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
     *              Department scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     *              for EnrollmentAccount scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *              for BillingProfile scope,
     *              'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     *              for InvoiceSection scope,
     *              'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
     *              External Billing Account scope and
     *              'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for External
     *              Subscription scope. Note: Insight Alerts are only available on subscription scope.
     * @param nextLink The nextLink from the previous successful call to the ListByScope method.
     * @param options The options parameters.
     */
    _listByScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listByScopeNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.CostManagement/scheduledActions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduledActionListResult
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/scheduledActions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduledActionListResult
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec = {
    path: "/providers/Microsoft.CostManagement/scheduledActions/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ScheduledAction
        },
        201: {
            bodyMapper: ScheduledAction
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    requestBody: scheduledAction,
    queryParameters: [apiVersion],
    urlParameters: [$host, name],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/providers/Microsoft.CostManagement/scheduledActions/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduledAction
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/providers/Microsoft.CostManagement/scheduledActions/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateByScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ScheduledAction
        },
        201: {
            bodyMapper: ScheduledAction
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    requestBody: scheduledAction,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, name],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
const getByScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduledAction
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteByScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const runOperationSpec = {
    path: "/providers/Microsoft.CostManagement/scheduledActions/{name}/execute",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const runByScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/scheduledActions/{name}/execute",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const checkNameAvailabilityOperationSpec = {
    path: "/providers/Microsoft.CostManagement/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    requestBody: checkNameAvailabilityRequest,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const checkNameAvailabilityByScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.CostManagement/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    requestBody: checkNameAvailabilityRequest,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduledActionListResult
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduledActionListResult
        },
        default: {
            bodyMapper: ErrorResponseWithNestedDetails
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BenefitRecommendations operations. */
class BenefitRecommendationsImpl {
    /**
     * Initialize a new instance of the class BenefitRecommendations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of recommendations for purchasing savings plan.
     * @param billingScope The scope associated with benefit recommendation operations. This includes
     *                     '/subscriptions/{subscriptionId}/' for subscription scope,
     *                     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resource group scope,
     *                     /providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for enterprise agreement scope, and
     *                     '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *                     for billing profile scope
     * @param options The options parameters.
     */
    list(billingScope, options) {
        const iter = this.listPagingAll(billingScope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(billingScope, options, settings);
            }
        };
    }
    listPagingPage(billingScope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(billingScope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(billingScope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(billingScope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(billingScope, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of recommendations for purchasing savings plan.
     * @param billingScope The scope associated with benefit recommendation operations. This includes
     *                     '/subscriptions/{subscriptionId}/' for subscription scope,
     *                     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resource group scope,
     *                     /providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for enterprise agreement scope, and
     *                     '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *                     for billing profile scope
     * @param options The options parameters.
     */
    _list(billingScope, options) {
        return this.client.sendOperationRequest({ billingScope, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param billingScope The scope associated with benefit recommendation operations. This includes
     *                     '/subscriptions/{subscriptionId}/' for subscription scope,
     *                     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resource group scope,
     *                     /providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for enterprise agreement scope, and
     *                     '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     *                     for billing profile scope
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(billingScope, nextLink, options) {
        return this.client.sendOperationRequest({ billingScope, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/{billingScope}/providers/Microsoft.CostManagement/benefitRecommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitRecommendationsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        expand,
        orderby
    ],
    urlParameters: [$host, billingScope],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitRecommendationsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        billingScope
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BenefitUtilizationSummaries operations. */
class BenefitUtilizationSummariesImpl {
    /**
     * Initialize a new instance of the class BenefitUtilizationSummaries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists savings plan utilization summaries for the enterprise agreement scope. Supported at grain
     * values: 'Daily' and 'Monthly'.
     * @param billingAccountId Billing account ID
     * @param options The options parameters.
     */
    listByBillingAccountId(billingAccountId, options) {
        const iter = this.listByBillingAccountIdPagingAll(billingAccountId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByBillingAccountIdPagingPage(billingAccountId, options, settings);
            }
        };
    }
    listByBillingAccountIdPagingPage(billingAccountId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByBillingAccountIdPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByBillingAccountId(billingAccountId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByBillingAccountIdNext(billingAccountId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByBillingAccountIdPagingAll(billingAccountId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByBillingAccountIdPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByBillingAccountIdPagingPage(billingAccountId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists savings plan utilization summaries for billing profile. Supported at grain values: 'Daily' and
     * 'Monthly'.
     * @param billingAccountId Billing account ID
     * @param billingProfileId Billing profile ID.
     * @param options The options parameters.
     */
    listByBillingProfileId(billingAccountId, billingProfileId, options) {
        const iter = this.listByBillingProfileIdPagingAll(billingAccountId, billingProfileId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByBillingProfileIdPagingPage(billingAccountId, billingProfileId, options, settings);
            }
        };
    }
    listByBillingProfileIdPagingPage(billingAccountId, billingProfileId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByBillingProfileIdPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByBillingProfileId(billingAccountId, billingProfileId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByBillingProfileIdNext(billingAccountId, billingProfileId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByBillingProfileIdPagingAll(billingAccountId, billingProfileId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByBillingProfileIdPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByBillingProfileIdPagingPage(billingAccountId, billingProfileId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the savings plan utilization summaries for daily or monthly grain.
     * @param savingsPlanOrderId Savings plan order ID.
     * @param options The options parameters.
     */
    listBySavingsPlanOrder(savingsPlanOrderId, options) {
        const iter = this.listBySavingsPlanOrderPagingAll(savingsPlanOrderId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySavingsPlanOrderPagingPage(savingsPlanOrderId, options, settings);
            }
        };
    }
    listBySavingsPlanOrderPagingPage(savingsPlanOrderId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySavingsPlanOrderPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySavingsPlanOrder(savingsPlanOrderId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySavingsPlanOrderNext(savingsPlanOrderId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySavingsPlanOrderPagingAll(savingsPlanOrderId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySavingsPlanOrderPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySavingsPlanOrderPagingPage(savingsPlanOrderId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists the savings plan utilization summaries for daily or monthly grain.
     * @param savingsPlanOrderId Savings plan order ID.
     * @param savingsPlanId Savings plan ID.
     * @param options The options parameters.
     */
    listBySavingsPlanId(savingsPlanOrderId, savingsPlanId, options) {
        const iter = this.listBySavingsPlanIdPagingAll(savingsPlanOrderId, savingsPlanId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySavingsPlanIdPagingPage(savingsPlanOrderId, savingsPlanId, options, settings);
            }
        };
    }
    listBySavingsPlanIdPagingPage(savingsPlanOrderId, savingsPlanId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySavingsPlanIdPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySavingsPlanId(savingsPlanOrderId, savingsPlanId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySavingsPlanIdNext(savingsPlanOrderId, savingsPlanId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySavingsPlanIdPagingAll(savingsPlanOrderId, savingsPlanId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySavingsPlanIdPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySavingsPlanIdPagingPage(savingsPlanOrderId, savingsPlanId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists savings plan utilization summaries for the enterprise agreement scope. Supported at grain
     * values: 'Daily' and 'Monthly'.
     * @param billingAccountId Billing account ID
     * @param options The options parameters.
     */
    _listByBillingAccountId(billingAccountId, options) {
        return this.client.sendOperationRequest({ billingAccountId, options }, listByBillingAccountIdOperationSpec);
    }
    /**
     * Lists savings plan utilization summaries for billing profile. Supported at grain values: 'Daily' and
     * 'Monthly'.
     * @param billingAccountId Billing account ID
     * @param billingProfileId Billing profile ID.
     * @param options The options parameters.
     */
    _listByBillingProfileId(billingAccountId, billingProfileId, options) {
        return this.client.sendOperationRequest({ billingAccountId, billingProfileId, options }, listByBillingProfileIdOperationSpec);
    }
    /**
     * Lists the savings plan utilization summaries for daily or monthly grain.
     * @param savingsPlanOrderId Savings plan order ID.
     * @param options The options parameters.
     */
    _listBySavingsPlanOrder(savingsPlanOrderId, options) {
        return this.client.sendOperationRequest({ savingsPlanOrderId, options }, listBySavingsPlanOrderOperationSpec);
    }
    /**
     * Lists the savings plan utilization summaries for daily or monthly grain.
     * @param savingsPlanOrderId Savings plan order ID.
     * @param savingsPlanId Savings plan ID.
     * @param options The options parameters.
     */
    _listBySavingsPlanId(savingsPlanOrderId, savingsPlanId, options) {
        return this.client.sendOperationRequest({ savingsPlanOrderId, savingsPlanId, options }, listBySavingsPlanIdOperationSpec);
    }
    /**
     * ListByBillingAccountIdNext
     * @param billingAccountId Billing account ID
     * @param nextLink The nextLink from the previous successful call to the ListByBillingAccountId method.
     * @param options The options parameters.
     */
    _listByBillingAccountIdNext(billingAccountId, nextLink, options) {
        return this.client.sendOperationRequest({ billingAccountId, nextLink, options }, listByBillingAccountIdNextOperationSpec);
    }
    /**
     * ListByBillingProfileIdNext
     * @param billingAccountId Billing account ID
     * @param billingProfileId Billing profile ID.
     * @param nextLink The nextLink from the previous successful call to the ListByBillingProfileId method.
     * @param options The options parameters.
     */
    _listByBillingProfileIdNext(billingAccountId, billingProfileId, nextLink, options) {
        return this.client.sendOperationRequest({ billingAccountId, billingProfileId, nextLink, options }, listByBillingProfileIdNextOperationSpec);
    }
    /**
     * ListBySavingsPlanOrderNext
     * @param savingsPlanOrderId Savings plan order ID.
     * @param nextLink The nextLink from the previous successful call to the ListBySavingsPlanOrder method.
     * @param options The options parameters.
     */
    _listBySavingsPlanOrderNext(savingsPlanOrderId, nextLink, options) {
        return this.client.sendOperationRequest({ savingsPlanOrderId, nextLink, options }, listBySavingsPlanOrderNextOperationSpec);
    }
    /**
     * ListBySavingsPlanIdNext
     * @param savingsPlanOrderId Savings plan order ID.
     * @param savingsPlanId Savings plan ID.
     * @param nextLink The nextLink from the previous successful call to the ListBySavingsPlanId method.
     * @param options The options parameters.
     */
    _listBySavingsPlanIdNext(savingsPlanOrderId, savingsPlanId, nextLink, options) {
        return this.client.sendOperationRequest({ savingsPlanOrderId, savingsPlanId, nextLink, options }, listBySavingsPlanIdNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByBillingAccountIdOperationSpec = {
    path: "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        grainParameter,
        filter1
    ],
    urlParameters: [$host, billingAccountId],
    headerParameters: [accept],
    serializer
};
const listByBillingProfileIdOperationSpec = {
    path: "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        grainParameter,
        filter1
    ],
    urlParameters: [
        $host,
        billingAccountId,
        billingProfileId
    ],
    headerParameters: [accept],
    serializer
};
const listBySavingsPlanOrderOperationSpec = {
    path: "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        grainParameter
    ],
    urlParameters: [$host, savingsPlanOrderId],
    headerParameters: [accept],
    serializer
};
const listBySavingsPlanIdOperationSpec = {
    path: "/providers/Microsoft.BillingBenefits/savingsPlanOrders/{savingsPlanOrderId}/savingsPlans/{savingsPlanId}/providers/Microsoft.CostManagement/benefitUtilizationSummaries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        grainParameter
    ],
    urlParameters: [
        $host,
        savingsPlanOrderId,
        savingsPlanId
    ],
    headerParameters: [accept],
    serializer
};
const listByBillingAccountIdNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        billingAccountId
    ],
    headerParameters: [accept],
    serializer
};
const listByBillingProfileIdNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        billingAccountId,
        billingProfileId
    ],
    headerParameters: [accept],
    serializer
};
const listBySavingsPlanOrderNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        savingsPlanOrderId
    ],
    headerParameters: [accept],
    serializer
};
const listBySavingsPlanIdNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BenefitUtilizationSummariesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        savingsPlanOrderId,
        savingsPlanId
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class CostManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the CostManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param options The parameter options
     */
    constructor(credentials, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-costmanagement/1.0.0-beta.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2022-10-01";
        this.operations = new OperationsImpl(this);
        this.views = new ViewsImpl(this);
        this.alerts = new AlertsImpl(this);
        this.forecast = new ForecastImpl(this);
        this.dimensions = new DimensionsImpl(this);
        this.query = new QueryImpl(this);
        this.generateReservationDetailsReport = new GenerateReservationDetailsReportImpl(this);
        this.exports = new ExportsImpl(this);
        this.generateCostDetailsReport = new GenerateCostDetailsReportImpl(this);
        this.generateDetailedCostReport = new GenerateDetailedCostReportImpl(this);
        this.generateDetailedCostReportOperationResults = new GenerateDetailedCostReportOperationResultsImpl(this);
        this.generateDetailedCostReportOperationStatus = new GenerateDetailedCostReportOperationStatusImpl(this);
        this.priceSheet = new PriceSheetImpl(this);
        this.scheduledActions = new ScheduledActionsImpl(this);
        this.benefitRecommendations = new BenefitRecommendationsImpl(this);
        this.benefitUtilizationSummaries = new BenefitUtilizationSummariesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.CostManagementClient = CostManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
